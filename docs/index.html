<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Ampersand.js, Javascript, ampersand, Node.js, Apps, HTML5">
    <meta name="author" content="Get started with Ampersand.js">
    <title>Ampersand.js - Documentation</title>
    <link rel="stylesheet" href="//cloud.typography.com/7773252/613684/css/fonts.css">
    <link rel="stylesheet" href="/public/css/normalize.min.css">
    <link rel="stylesheet" href="/public/css/main.css">
    <script>
      !function(g,s,q,r,d){r=g[r]=g[r]||function(){(r.q=r.q||[]).push(
      arguments)};d=s.createElement(q);q=s.getElementsByTagName(q)[0];
      d.src='//d1l6p2sc9645hc.cloudfront.net/tracker.js';q.parentNode.
      insertBefore(d,q)}(window,document,'script','_gs');
      _gs('GSN-375569-B', false);
      _gs('set', 'cookieDomain', '.ampersandjs.com');
      _gs('track');
    </script>
  </head>
  <body class="docs-page">
    <nav class="nav-main cf"><a href="/" class="logo logo-ampersand">Ampersand.js</a><a href="/learn" class="nav-item">Learn</a><a href="/docs" class="nav-item active">Docs</a><a href="http://tools.ampersandjs.com" class="nav-item external">Find Modules</a><a href="http://amp.ampersandjs.com/" class="nav-item external">Amp</a><a href="https://gitter.im/AmpersandJS/AmpersandJS" class="nav-item external">Chatroom</a><a href="/contribute" class="nav-item">Contribute</a><a href="/learn/quick-start-guide/" class="button button-primary">Get Started</a></nav>
    <div class="docs cf">
      <nav class="nav-docs"><a href="/" class="logo logo-ampersand"></a><a href="#intro" class="section-top">Introduction</a><a href="#ampersand" class="section-top">The Ampersand CLI</a><a href="#ampersand-installation" class="section-sub">Installation</a><a href="#ampersand-starting-a-new-app" class="section-sub">Starting a new app</a><a href="#ampersand-generating-stuff" class="section-sub">Generating stuff</a><a href="#ampersand-generating-models-from-json" class="section-sub">Generating models (from JSON)</a><a href="#ampersand-generating-forms-from-models" class="section-sub">Generating forms from models</a><a href="#ampersand-configuring-the-generated-code" class="section-sub">Configuring the generated code</a><a href="#ampersand-sample-json-with-default-options" class="section-sub-sub">Sample JSON with default options</a><a href="#ampersand-app" class="section-top">ampersand-app</a><a href="#ampersand-app-the-singleton-pattern" class="section-sub">The Singleton pattern</a><a href="#ampersand-app-why-is-this-useful" class="section-sub">Why is this useful?</a><a href="#ampersand-app-warning-not-for-use-in-re-usable-modules" class="section-sub">Warning: Not for use in re-usable modules</a><a href="#ampersand-app-install" class="section-sub">install</a><a href="#ampersand-app-api-reference" class="section-sub">API Reference</a><a href="#ampersand-app-event-methods" class="section-sub-sub">event methods</a><a href="#ampersand-app-extend" class="section-sub-sub">extend <code>app.extend(obj, [*objs])</code></a><a href="#ampersand-app-reset" class="section-sub-sub">reset <code>app.reset()</code></a><a href="#ampersand-state" class="section-top">ampersand-state</a><a href="#ampersand-state-install" class="section-sub">Install</a><a href="#ampersand-state-api-reference" class="section-sub">API Reference</a><a href="#ampersand-state-extend" class="section-sub-sub">extend <code>AmpersandState.extend({ })</code></a><a href="#ampersand-state-constructorinitialize" class="section-sub-sub">constructor/initialize <code>new AmpersandState([attrs], [options])</code></a><a href="#ampersand-state-idattribute" class="section-sub-sub">idAttribute <code>state.idAttribute</code></a><a href="#ampersand-state-getid" class="section-sub-sub">getId <code>state.getId()</code></a><a href="#ampersand-state-namespaceattribute" class="section-sub-sub">namespaceAttribute <code>state.namespaceAttribute</code></a><a href="#ampersand-state-getnamespace" class="section-sub-sub">getNamespace <code>state.getNamespace()</code></a><a href="#ampersand-state-typeattribute" class="section-sub-sub">typeAttribute</a><a href="#ampersand-state-gettype" class="section-sub-sub">getType <code>state.getType()</code></a><a href="#ampersand-state-extraproperties" class="section-sub-sub">extraProperties <code>AmpersandState.extend({ extraProperties: &#39;allow&#39; })</code></a><a href="#ampersand-state-collection" class="section-sub-sub">collection <code>state.collection</code></a><a href="#ampersand-state-cid" class="section-sub-sub">cid <code>state.cid</code></a><a href="#ampersand-state-isnew" class="section-sub-sub">isNew <code>state.isNew()</code></a><a href="#ampersand-state-escape" class="section-sub-sub">escape <code>state.escape()</code></a><a href="#ampersand-state-isvalid" class="section-sub-sub">isValid <code>state.isValid()</code></a><a href="#ampersand-state-datatypes" class="section-sub-sub">dataTypes  <code>AmpersandState.extend({ datatypes: myCustomTypes })</code></a><a href="#ampersand-state-props" class="section-sub-sub">props <code>AmpersandState.extend({ props: { name: &#39;string&#39; } })</code></a><a href="#ampersand-state-session" class="section-sub-sub">session <code>AmpersandState.extend({ session: { name: &#39;string&#39; } })</code></a><a href="#ampersand-state-derived" class="section-sub-sub">derived <code>AmpersandState.extend({ derived: { derivedProperties }})</code></a><a href="#ampersand-state-children" class="section-sub-sub">children <code>AmpersandState.extend({ children: { profile: Profile } })</code></a><a href="#ampersand-state-collections" class="section-sub-sub">collections <code>AmpersandState.extend({ collections: { widgets: Widgets } })</code></a><a href="#ampersand-state-parse" class="section-sub-sub">parse</a><a href="#ampersand-state-serialize" class="section-sub-sub">serialize <code>state.serialize([options])</code></a><a href="#ampersand-state-get" class="section-sub-sub">get <code>state.get(attribute); state[attribute]; state.firstName</code></a><a href="#ampersand-state-set" class="section-sub-sub">set <code>state.set(attributes, [options]); state.firstName = &#39;Henrik&#39;;</code></a><a href="#ampersand-state-unset" class="section-sub-sub">unset <code>state.unset(attribute|attributes[], [options])</code></a><a href="#ampersand-state-clear" class="section-sub-sub">clear <code>state.clear([options])</code></a><a href="#ampersand-state-toggle" class="section-sub-sub">toggle <code>state.toggle(&#39;a&#39;)</code></a><a href="#ampersand-state-previousattributes" class="section-sub-sub">previousAttributes <code>state.previousAttributes()</code></a><a href="#ampersand-state-haschanged" class="section-sub-sub">hasChanged <code>state.hasChanged([attribute])</code></a><a href="#ampersand-state-changedattributes" class="section-sub-sub">changedAttributes <code>state.changedAttributes([objectToDiff])</code></a><a href="#ampersand-state-tojson" class="section-sub-sub">toJSON <code>state.toJSON()</code></a><a href="#ampersand-state-getattributes" class="section-sub-sub">getAttributes <code>state.getAttributes([options, raw])</code></a><a href="#ampersand-model" class="section-top">ampersand-model</a><a href="#ampersand-model-installing" class="section-sub">Installing</a><a href="#ampersand-model-observing" class="section-sub">Observing</a><a href="#ampersand-model-api-reference" class="section-sub">API Reference</a><a href="#ampersand-model-extend" class="section-sub-sub">extend <code>AmpersandModel.extend({ })</code></a><a href="#ampersand-model-constructorinitialize" class="section-sub-sub">constructor/initialize <code>new ExtendedAmpersandModel([attrs], [options])</code></a><a href="#ampersand-model-save" class="section-sub-sub">save <code>model.save([attributes], [options])</code></a><a href="#ampersand-model-fetch" class="section-sub-sub">fetch <code>model.fetch([options])</code></a><a href="#ampersand-model-destroy" class="section-sub-sub">destroy <code>model.destroy([options])</code></a><a href="#ampersand-model-sync" class="section-sub-sub">sync <code>model.sync(method, model, [options])</code></a><a href="#ampersand-model-configuring" class="section-sub">Configuring</a><a href="#ampersand-model-ajaxconfig" class="section-sub-sub">ajaxConfig <code>model.ajaxConfig or model.ajaxConfig()</code></a><a href="#ampersand-model-url" class="section-sub-sub">url <code>model.url or model.url()</code></a><a href="#ampersand-model-urlroot" class="section-sub-sub">urlRoot <code>model.urlRoot or model.urlRoot()</code></a><a href="#ampersand-collection" class="section-top">ampersand-collection</a><a href="#ampersand-collection-installation" class="section-sub">Installation</a><a href="#ampersand-collection-api-reference" class="section-sub">API Reference</a><a href="#ampersand-collection-extend" class="section-sub-sub">extend <code>AmpersandCollection.extend([attributes])</code></a><a href="#ampersand-collection-model" class="section-sub-sub">model <code>collection.model</code></a><a href="#ampersand-collection-constructorinitialize" class="section-sub-sub">constructor/initialize <code>new AmpersandCollection([models [, options]])</code></a><a href="#ampersand-collection-mainindex" class="section-sub-sub">mainIndex <code>collection.mainIndex</code></a><a href="#ampersand-collection-indexes" class="section-sub-sub">indexes <code>collections.indexes</code></a><a href="#ampersand-collection-length" class="section-sub-sub">length <code>collection.length</code></a><a href="#ampersand-collection-iscollectioninstanceof" class="section-sub-sub">isCollection/instanceof <code>collection.isCollection</code></a><a href="#ampersand-collection-add" class="section-sub-sub">add <code>collection.add(modelOrObject, [options])</code></a><a href="#ampersand-collection-serialize" class="section-sub-sub">serialize <code>collection.serialize()</code></a><a href="#ampersand-collection-tojson" class="section-sub-sub">toJSON <code>collection.toJSON()</code></a><a href="#ampersand-collection-parse" class="section-sub-sub">parse <code>collection.parse(data, [options])</code></a><a href="#ampersand-collection-set" class="section-sub-sub">set <code>collection.set(models, [options])</code></a><a href="#ampersand-collection-get" class="section-sub-sub">get <code>collection.get(query, [indexName])</code></a><a href="#ampersand-collection-at" class="section-sub-sub">at <code>collection.at(index)</code></a><a href="#ampersand-collection-remove" class="section-sub-sub">remove <code>collection.remove(models, [options])</code></a><a href="#ampersand-collection-reset" class="section-sub-sub">reset <code>collection.reset(models, [options])</code></a><a href="#ampersand-collection-sort" class="section-sub-sub">sort <code>collection.sort([options])</code></a><a href="#ampersand-collection-models" class="section-sub-sub">models <code>collection.models</code></a><a href="#ampersand-collection-comparator" class="section-sub-sub">comparator</a><a href="#ampersand-collection-proxied-es5-array-methods-9" class="section-sub-sub">proxied ES5 array methods (9)</a><a href="#ampersand-rest-collection" class="section-top">ampersand-rest-collection</a><a href="#ampersand-rest-collection-install" class="section-sub">Install</a><a href="#ampersand-rest-collection-api-reference" class="section-sub">API Reference</a><a href="#ampersand-rest-collection-ajaxconfig" class="section-sub-sub">ajaxConfig <code>AmpersandRestCollection.extend({ ajaxConfig: function () { ... } })</code></a><a href="#ampersand-rest-collection-fetch" class="section-sub-sub">fetch <code>collection.fetch([options])</code></a><a href="#ampersand-rest-collection-getorfetch" class="section-sub-sub">getOrFetch <code>collection.getOrFetch(&#39;id&#39;, [options], callback)</code></a><a href="#ampersand-rest-collection-fetchbyid" class="section-sub-sub">fetchById <code>collection.fetchById(&#39;id&#39;, callback)</code></a><a href="#ampersand-rest-collection-create" class="section-sub-sub">create <code>collection.create(model, [options])</code></a><a href="#ampersand-rest-collection-sync" class="section-sub-sub">sync <code>model.sync(method, collection, [options])</code></a><a href="#ampersand-rest-collection-lodash-methods-42" class="section-sub-sub">lodash methods (42)</a><a href="#ampersand-view" class="section-top">ampersand-view</a><a href="#ampersand-view-install" class="section-sub">Install</a><a href="#ampersand-view-api-reference" class="section-sub">API Reference</a><a href="#ampersand-view-extend" class="section-sub-sub">extend <code>AmpersandView.extend([properties])</code></a><a href="#ampersand-view-template" class="section-sub-sub">template <code>AmpersandView.extend({ template: &quot;&lt;div&gt;&lt;input&gt;&lt;/div&gt;&quot; })</code></a><a href="#ampersand-view-autorender" class="section-sub-sub">autoRender <code>AmpersandView.extend({ autoRender: true })</code></a><a href="#ampersand-view-events" class="section-sub-sub">events <code>AmpersandView.extend({ events: { /* ...events hash... */ } })</code></a><a href="#ampersand-view-bindings" class="section-sub-sub">bindings</a><a href="#ampersand-view-el" class="section-sub-sub">el <code>view.el</code></a><a href="#ampersand-view-constructor" class="section-sub-sub">constructor <code>new AmpersandView([options])</code></a><a href="#ampersand-view-initialize" class="section-sub-sub">initialize <code>new AmpersandView([options])</code></a><a href="#ampersand-view-render" class="section-sub-sub">render <code>view.render()</code></a><a href="#ampersand-view-rendercollection" class="section-sub-sub">renderCollection <code>view.renderCollection(collection, ItemView, containerEl, [viewOptions])</code></a><a href="#ampersand-view-renderwithtemplate" class="section-sub-sub">renderWithTemplate <code>view.renderWithTemplate([context], [template])</code></a><a href="#ampersand-view-query" class="section-sub-sub">query <code>view.query(&#39;.classname&#39;)</code></a><a href="#ampersand-view-querybyhook" class="section-sub-sub">queryByHook <code>view.queryByHook(&#39;hookname&#39;)</code></a><a href="#ampersand-view-queryall" class="section-sub-sub">queryAll <code>view.queryAll(&#39;.classname&#39;)</code></a><a href="#ampersand-view-queryallbyhook" class="section-sub-sub">queryAllByHook <code>view.queryAllByHook(&#39;hookname&#39;)</code></a><a href="#ampersand-view-cacheelements" class="section-sub-sub">cacheElements <code>view.cacheElements(hash)</code></a><a href="#ampersand-view-listentoandrun" class="section-sub-sub">listenToAndRun <code>view.listenToAndRun(object, eventsString, callback)</code></a><a href="#ampersand-view-remove" class="section-sub-sub">remove <code>view.remove()</code></a><a href="#ampersand-view-registersubview" class="section-sub-sub">registerSubview <code>view.registerSubview(viewInstance)</code></a><a href="#ampersand-view-rendersubview" class="section-sub-sub">renderSubview <code>view.renderSubview(viewInstance, containerEl)</code></a><a href="#ampersand-view-subviews" class="section-sub-sub">subviews <code>view.subviews</code></a><a href="#ampersand-view-delegateevents" class="section-sub-sub">delegateEvents <code>view.delegateEvents([events])</code></a><a href="#ampersand-view-undelegateevents" class="section-sub-sub">undelegateEvents <code>view.undelegateEvents()</code></a><a href="#ampersand-view-switcher" class="section-top">ampersand-view-switcher</a><a href="#ampersand-view-switcher-purpose" class="section-sub">Purpose</a><a href="#ampersand-view-switcher-install" class="section-sub">Install</a><a href="#ampersand-view-switcher-example" class="section-sub">Example</a><a href="#ampersand-view-switcher-api-reference" class="section-sub">API Reference</a><a href="#ampersand-view-switcher-constructor" class="section-sub-sub">constructor <code>new ViewSwitcher(element, [options])</code></a><a href="#ampersand-view-switcher-set" class="section-sub-sub">set <code>switcher.set(viewInstance)</code></a><a href="#ampersand-view-switcher-clear" class="section-sub-sub">clear <code>switcher.clear(callback)</code></a><a href="#ampersand-router" class="section-top">ampersand-router</a><a href="#ampersand-router-install" class="section-sub">install</a><a href="#ampersand-router-api-reference" class="section-sub">API Reference</a><a href="#ampersand-router-extend" class="section-sub-sub">extend <code>AmpersandRouter.extend(properties)</code></a><a href="#ampersand-router-routes" class="section-sub-sub">routes <code>router.routes</code></a><a href="#ampersand-router-constructor-initialize" class="section-sub-sub">constructor / initialize <code>new Router([options])</code></a><a href="#ampersand-router-route" class="section-sub-sub">route <code>router.route(route, name, [callback])</code></a><a href="#ampersand-router-navigate" class="section-sub-sub">navigate <code>router.navigate(fragment, [options])</code></a><a href="#ampersand-router-reload" class="section-sub-sub">reload <code>router.reload()</code></a><a href="#ampersand-router-redirectto" class="section-sub-sub">redirectTo <code>router.redirectTo(fragment)</code></a><a href="#ampersand-router-execute" class="section-sub-sub">execute <code>router.execute(callback, args)</code></a><a href="#ampersand-router-historystart" class="section-sub-sub">history.start <code>router.history.start([options])</code></a><a href="#ampersand-events" class="section-top">ampersand-events</a><a href="#ampersand-events-install" class="section-sub">Install</a><a href="#ampersand-events-example-usage" class="section-sub">Example usage</a><a href="#ampersand-events-adding-events-to-a-constructor-or-quotclassquot" class="section-sub-sub">Adding events to a constructor or &quot;class&quot;</a><a href="#ampersand-events-using-with-plain-objects" class="section-sub-sub">Using with plain objects</a><a href="#ampersand-events-using-as-an-event-bus-or-pubsub-channel" class="section-sub-sub">Using as an event bus / or pubsub channel</a><a href="#ampersand-events-api-reference" class="section-sub">API Reference</a><a href="#ampersand-events-createemitter" class="section-sub-sub">createEmitter <code>Events.createEmitter([object])</code></a><a href="#ampersand-events-on" class="section-sub-sub">on <code>eventObj.on(eventName, callback, [context])</code></a><a href="#ampersand-events-once" class="section-sub-sub">once <code>eventObj.once(eventName, callback, [context])</code></a><a href="#ampersand-events-off" class="section-sub-sub">off <code>eventObj.off([eventName], [callback], [context])</code></a><a href="#ampersand-events-trigger" class="section-sub-sub">trigger <code>eventObj.trigger(eventName, [argsToPassOn])</code></a><a href="#ampersand-events-listento" class="section-sub-sub">listenTo <code>eventObj.listenTo(otherEventObj, eventName, callback)</code></a><a href="#ampersand-events-listentoonce" class="section-sub-sub">listenToOnce <code>eventObj.listenToOnce(otherEventObj, eventName, callback)</code></a><a href="#ampersand-events-listentoandrun" class="section-sub-sub">listenToAndRun <code>eventObj.listenToAndRun(otherEventObj, eventName, callback)</code></a><a href="#ampersand-events-stoplistening" class="section-sub-sub">stopListening <code>eventObj.stopListening([otherEventObj], [eventName], [callback])</code></a><a href="#ampersand-dom-bindings" class="section-top">ampersand-dom-bindings</a><a href="#ampersand-dom-bindings-install" class="section-sub">install</a><a href="#ampersand-dom-bindings-binding-types" class="section-sub">Binding types</a><a href="#ampersand-dom-bindings-text" class="section-sub-sub">text</a><a href="#ampersand-dom-bindings-class" class="section-sub-sub">class</a><a href="#ampersand-dom-bindings-attribute" class="section-sub-sub">attribute</a><a href="#ampersand-dom-bindings-value" class="section-sub-sub">value</a><a href="#ampersand-dom-bindings-booleanclass" class="section-sub-sub">booleanClass</a><a href="#ampersand-dom-bindings-booleanattribute" class="section-sub-sub">booleanAttribute</a><a href="#ampersand-dom-bindings-toggle" class="section-sub-sub">toggle</a><a href="#ampersand-dom-bindings-switch" class="section-sub-sub">switch</a><a href="#ampersand-dom-bindings-switchclass" class="section-sub-sub">switchClass</a><a href="#ampersand-dom-bindings-switchattribute" class="section-sub-sub">switchAttribute</a><a href="#ampersand-dom-bindings-innerhtml" class="section-sub-sub">innerHTML</a><a href="#ampersand-dom-bindings-custom-functions" class="section-sub-sub">custom functions</a><a href="#ampersand-dom-bindings-handling-multiple-bindings-for-a-given-key" class="section-sub">Handling multiple bindings for a given key</a><a href="#ampersand-dom-bindings-binding-using-attribute" class="section-sub">binding using <code>data-hook</code> attribute</a><a href="#ampersand-dom-bindings-handling-simplest-cases-text" class="section-sub">handling simplest cases: text</a><a href="#ampersand-dom-bindings-real-life-example" class="section-sub">real life example</a><a href="#ampersand-dom-bindings-other-benefits" class="section-sub">other benefits</a>
      </nav>
      <div class="docs-content">
        <section><a name="intro" href="#intro" class="anchor">
            <h1><span class="header-link"></span>API Documentation</h1></a>
          <p>This page has consolidated API reference documentation for the core modules in a single page for the sake of being 'cmd+f' friendly.</p>
          <p>For more in-depth guides, conventions, best practices, and how to use these tools together please see <a href="/learn">guides</a>.</p>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand" href="#ampersand" class="anchor">
            <h1><span class="header-link"></span>The Ampersand CLI</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand</h4>
            <p class="module-version">latest v3.0.6</p>
            <p class="module-description">CLI tool for generating single page apps a. la. http://humanjavascript.com</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand">github</a><a href="https://www.npmjs.org/package/ampersand">npm</a></p>
          </div>
          <div><p>Lead Maintainer: <a href="https://github.com/fyockm">Drew Fyock</a></p>
<p>The idea behind the CLI is not to solve all your problems and write all your code, but to help you with the tedious parts of building an app, which is what computers are supposed to help us with.</p>
<a name="ampersand-installation" class="anchor" href="#ampersand-installation"><h2><span class="header-link"></span>Installation</h2></a><pre><code>npm install -g ampersand
</code></pre><a name="ampersand-starting-a-new-app" class="anchor" href="#ampersand-starting-a-new-app"><h2><span class="header-link"></span>Starting a new app</h2></a><p>Just, <code>cd</code> into whatever directory you normally put your projects in and just run <code>ampersand</code>.</p>
<p>The CLI will walk you through some basic questions, and kick out an app that runs out of the box.</p>
<p>It&#39;s meant to be a loose guide, not an edict. Just delete whatever isn&#39;t relevant.</p>
<a name="ampersand-generating-stuff" class="anchor" href="#ampersand-generating-stuff"><h2><span class="header-link"></span>Generating stuff</h2></a><pre><code>ampersand gen {{type}}
</code></pre><p>Type can be <code>form</code>, <code>view</code>, <code>model</code> or <code>collection</code>.</p>
<a name="ampersand-generating-models-from-json" class="anchor" href="#ampersand-generating-models-from-json"><h2><span class="header-link"></span>Generating models (from JSON)</h2></a><p>You can use the CLI to generate a model and collection for that model. If you already know what the JSON is going to look like you can pipe it into the generator to create a model with matching properties.</p>
<p>On a Mac, if you&#39;ve copied some JSON to your clipboard you can do this from anywhere within your project folder:</p>
<pre><code>pbpaste | ampersand gen model MyModel
</code></pre><p>And it&#39;ll kick out two files in your models folder (which is configurable, see below):</p>
<pre><code>my-model.js
my-model-collection.js
</code></pre><p>And it will create the properties in the JSON object as model properties.</p>
<p>Don&#39;t worry, nothing will be overwritten unless you use the the <code>--force</code> (or <code>-f</code>) option</p>
<a name="ampersand-generating-forms-from-models" class="anchor" href="#ampersand-generating-forms-from-models"><h2><span class="header-link"></span>Generating forms from models</h2></a><p>You can also use a model to generate the starting point of a form-view for editing that model.</p>
<pre><code>ampersand gen form ./path/to/your/model.js
</code></pre><p>It will create a form view in your <code>/client/forms</code> folder.</p>
<p>Nothing will be overwritten unless you use the the <code>--force</code> (or <code>-f</code>) option, so it&#39;s safe to just experiment.</p>
<a name="ampersand-configuring-the-generated-code" class="anchor" href="#ampersand-configuring-the-generated-code"><h2><span class="header-link"></span>Configuring the generated code</h2></a><p>The cli looks for config options from a number of sources, starting with default, applying configs from a <code>.ampersandrc</code> in your home folder, then your project root, then by parsing option flags from stdin.</p>
<p>Those files can be JSON or ini format.</p>
<p>The available options and defaults are as follows:</p>
<ul>
<li><code>framework</code>: default framework to be prompted with, options are <code>express</code> or <code>hapi</code></li>
<li><code>indent</code>: indent size</li>
<li><code>view</code>: default template</li>
<li><code>router</code>: default template</li>
<li><code>model</code>: default template</li>
<li><code>page</code>: default template</li>
<li><code>collection</code>: default template</li>
<li><code>clientfolder</code>: name for the &#39;client&#39; folder</li>
<li><code>viewfolder</code>: name for the &#39;views&#39; folder</li>
<li><code>pagefolder</code>: name for the &#39;pages&#39; folder</li>
<li><code>modelfolder</code>: name for the &#39;models&#39; folder</li>
<li><code>formsfolder</code>: name for the &#39;forms&#39; folder</li>
<li><code>collectionfolder</code>: name for the collection folder - grouped with &#39;models&#39; by default</li>
<li><code>makecollection</code>: whether to create collection when making a model</li>
<li><code>approot</code>: if called without the &#39;gen&#39; command build a new one, so we won&#39;t look for an application root. starts walking up folders looking for <code>package.json</code>.</li>
<li><code>quotes</code>: options are &#39;single&#39; or &#39;double&#39;</li>
</ul>
<a name="ampersand-sample-json-with-default-options" class="anchor" href="#ampersand-sample-json-with-default-options"><h3><span class="header-link"></span>Sample JSON with default options</h3></a><pre><code class="javascripton">{
    &quot;framework&quot;: &quot;hapi&quot;,
    &quot;indent&quot;: 4,
    &quot;view&quot;: &quot;&quot;,
    &quot;router&quot;: &quot;&quot;,
    &quot;model&quot;: &quot;&quot;,
    &quot;page&quot;: &quot;&quot;,
    &quot;collection&quot;: &quot;&quot;,
    &quot;clientfolder&quot;: &quot;client&quot;,
    &quot;viewfolder&quot;: &quot;views&quot;,
    &quot;pagefolder&quot;: &quot;pages&quot;,
    &quot;modelfolder&quot;: &quot;models&quot;,
    &quot;formsfolder&quot;: &quot;forms&quot;,
    &quot;collectionfolder&quot;: &quot;models&quot;,
    &quot;makecollection&quot;: true,
    &quot;approot&quot;: &quot;&quot;,
    &quot;quotes&quot;: &quot;single&quot;
}
</code></pre>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-app/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-app" href="#ampersand-app" class="anchor">
            <h1><span class="header-link"></span>ampersand-app</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-app</h4>
            <p class="module-version">latest v1.0.4</p>
            <p class="module-description">Simple instance store for managing instances without circular dependency issues in ampersand apps.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-app">github</a><a href="https://www.npmjs.org/package/ampersand-app">npm</a></p>
          </div>
          <div><p>Simple instance store and event channel that allows different modules within your app to communicate without requiring each other directly. The entire module is only ~30 lines of code, you can <a href="https://github.com/AmpersandJS/ampersand-app/blob/master/ampersand-app.js">read the source here</a> to see exactly what it does.</p>
<a name="ampersand-app-the-singleton-pattern" class="anchor" href="#ampersand-app-the-singleton-pattern"><h2><span class="header-link"></span>The Singleton pattern</h2></a><p>Whenever you <code>require(&#39;ampersand-app&#39;)</code> it returns <em>the same instance of a plain &#39;ol JavaScript <code>Object</code></em>.</p>
<p>This is called the <a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern</a>. </p>
<p>This object it returns is nothing special. It&#39;s just a plain old JavaScript <code>Object</code> that has been decorated with <a href="http://ampersandjs.com/docs#ampersand-events">ampersand-events</a> methods as well as an <code>extend</code> and <code>reset</code> method.</p>
<p>That&#39;s it!</p>
<a name="ampersand-app-why-is-this-useful" class="anchor" href="#ampersand-app-why-is-this-useful"><h2><span class="header-link"></span>Why is this useful?</h2></a><p>It&#39;s quite common to create an <code>app</code> global to store collections and models on and then to reference that global whenever you need to look up related model instance from another module within your app. However, this creates many indirect interdependencies within your application which makes it more difficult to test isolated parts of your application. </p>
<p>It&#39;s also quite common to need &quot;application-level&quot; events that any number of pieces of your app may need to handle. For example, navigation events, or error events that could be triggered by any number of things within your app but that you want to handle by a single module that shows them as nice error dialogs.</p>
<p>This module provides a pattern to address both those cases without having to rely on globals, or have circular dependency issues within your apps. It also means you don&#39;t have to adjust code linting rules to ignore that <code>app</code> global.</p>
<p><strong>Before <code>ampersand-app</code></strong></p>
<p>Module &quot;A&quot; (app.js):</p>
<pre><code class="javascript">var MyModel = require(&#39;./models/some-model&#39;);

// explicitly create global
window.app = {
    init: function () {
        this.myModel = new MyModel();
    }
};

window.app.init();
</code></pre>
<p>Module &quot;B&quot; (that needs access to <code>app</code>):</p>
<pre><code class="javascript">// note we&#39;re not requiring anything
module.exports = View.extend({
    someMethod: function () {
        // reference app and models directly
        app.myModel.doSomething():
    }
});
</code></pre>
<p><strong>With <code>ampersand-app</code> you&#39;d do this instead:</strong></p>
<p>Module &quot;A&quot; (app.js):</p>
<pre><code class="javascript">// it just requires ampersand-app too!
var app = require(&#39;ampersand-app&#39;);
var MyModel = require(&#39;./models/some-model&#39;);

// Here we could certainly *chose* to attach it to
// window for better debugging in the browser 
// but it&#39;s no longer necessary for accessing the 
// app instance from other modules.
app.extend({
    init: function () {
        this.myModel = new MyModel();
    }
};

app.init();
</code></pre>
<p>Module &quot;B&quot; (that needs access to <code>app</code>):</p>
<pre><code class="javascript">// this just requires ampersand-app too!
var app = require(&#39;ampersand-app&#39;);


module.exports = View.extend({
    someMethod: function () {
        // reference app that we required above
        app.myModel.doSomething():

        // now as a bonus, since `app` supports events
        // we&#39;ve also got a global &quot;pubsub&quot; mechanism
        // for app events, that any other modules can 
        // listen to.
        app.trigger(&#39;some custom event&#39;);
    }
});
</code></pre>
<p>Now when we go to write tests for module &quot;B&quot; we can easily mock things that it expects from <code>app</code>. </p>
<p>So our tests for module B might look like this:</p>
<pre><code class="javascript">var test = require(&#39;tape&#39;);
var ModuleB = require(&#39;../module-b&#39;);
// note we just require ampersand-app here
// and make sure it has what module b expects
var app = require(&#39;ampersand-app&#39;);


test(&#39;test module B&#39;, function (t) {
    // each test can clear it.
    app.reset();
    // stub out what it might need for the
    // test.
    app.myModel = {
        doSomething: function () {}
    };

    // check to make sure calling 
    // `someMethod` fires event on app
    app.on(&#39;some custom event&#39;, function () {
        t.pass(&#39;custom event fired&#39;);

        // app also has a `reset` for testing
        // purposes that purges it to start over
        // so this could be used to reset before each test
        app.reset();

        t.end();
    });

    var view = new ModuleB();

    t.doesNotThrow(function () {
        view.someMethod();
    }, &#39;make sure calling some method does not explode&#39;);
});

test(&#39;next test&#39;, function () {
    // now we can use `reset` if we want
    // to make sure we clear that state
    app.reset();

    // etc. etc.
});
</code></pre>
<a name="ampersand-app-warning-not-for-use-in-re-usable-modules" class="anchor" href="#ampersand-app-warning-not-for-use-in-re-usable-modules"><h2><span class="header-link"></span>Warning: Not for use in re-usable modules</h2></a><p><strong>If you&#39;re writing a re-usable module for distribution on <a href="http://www.npmjs.org/">npm</a> it should not have <code>ampersand-app</code> as a dependency.</strong></p>
<p>Doing so makes assumptions about how you want it to be used.</p>
<p>Say you want to make an <code>error</code> event handling module, that requires <code>ampersand-app</code> listens for <code>error</code> events from that <code>app</code> and shows a nice error dialog. </p>
<p>Rather than make all those assumptions about how its going to be used, just make the nice error dialog view and suggest in the readme how someone might use <code>ampersand-app</code> as an event channel to trigger them.</p>
<p>This allows people who don&#39;t use this particular application pattern to still use your npm module and leaves the event names, and application architecture up to the person building the app.</p>
<a name="ampersand-app-install" class="anchor" href="#ampersand-app-install"><h2><span class="header-link"></span>install</h2></a><pre><code>npm install ampersand-app
</code></pre><a name="ampersand-app-api-reference" class="anchor" href="#ampersand-app-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-app-event-methods" class="anchor" href="#ampersand-app-event-methods"><h3><span class="header-link"></span>event methods</h3></a><p>The <code>app</code> object is an event object so it contains all the methods as described in the <a href="http://ampersandjs.com/docs#ampersand-events">ampersand-events docs</a>.</p>
<p>The <code>app</code> object becomes a handy way to communicate within your app so various modules can notify each other about &quot;app-level&quot; events such as user navigation, etc.</p>
<a name="ampersand-app-extend" class="anchor" href="#ampersand-app-extend"><h3><span class="header-link"></span>extend <code>app.extend(obj, [*objs])</code></h3></a><p>Convenience method for attaching multiple things to the app at once. This is simply an alias for <code>amp-extend</code> that pre-fills the <code>app</code> as the object being extended.</p>
<ul>
<li><code>obj</code> {Object} copy properties from this object onto <code>app</code>. You can pass as many objects to this as you want as additional arguments.</li>
</ul>
<pre><code class="javascript">var app = require(&#39;ampersand-app&#39;);
var UserCollection = require(&#39;./models/user-collection&#39;);
var MeModel = require(&#39;./models/me&#39;);


app.extend({
    me: new MeModel(),
    users: new UserCollection(),
    router: new Router(),
    init: function () {
        this.router.history.start({pushState: true});
    }
});
</code></pre>
<a name="ampersand-app-reset" class="anchor" href="#ampersand-app-reset"><h3><span class="header-link"></span>reset <code>app.reset()</code></h3></a><p>Resets the app singleton to its original state, clearing all listeners, and deleting everything you&#39;ve added to it, but keeping the same object instance.</p>
<p>This is primarily for simplifying unit testing of modules within your app. Whenever you <code>require(&#39;ampersand-app&#39;)</code> you get the same object instance (this is the <a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern</a>). So, having <code>app.reset()</code> lets you mock app state required for testing a given module.</p>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-state/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-state" href="#ampersand-state" class="anchor">
            <h1><span class="header-link"></span>ampersand-state</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-state</h4>
            <p class="module-version">latest v5.0.0</p>
            <p class="module-description">An observable, extensible state object with derived watchable properties.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-state">github</a><a href="https://www.npmjs.org/package/ampersand-state">npm</a></p>
          </div>
          <div><p><a href="https://coveralls.io/github/AmpersandJS/ampersand-state?branch=master"><img src="https://coveralls.io/repos/AmpersandJS/ampersand-state/badge.svg?branch=master&amp;service=github" alt="Coverage Status"></a></p>
<p>An observable, extensible state object with derived watchable properties.</p>
<p>Ampersand-state serves as a base object for <a href="http://github.com/ampersandjs/ampersand-model">ampersand-model</a> but is useful any time you want to track complex state.</p>
<p><a href="https://github.com/ampersandjs/ampersand-model">ampersand-model</a> extends ampersand-state to include assumptions that you&#39;d want if you&#39;re using models to model data from a REST API. But by itself ampersand-state is useful for anytime you want something to model state, that fires events for changes and lets you define and listen to derived properties.</p>
<p>For further explanation see the <a href="http://ampersandjs.com/learn/state">learn ampersand-state</a> guide.</p>
<a name="ampersand-state-install" class="anchor" href="#ampersand-state-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-state --save
</code></pre><a name="ampersand-state-api-reference" class="anchor" href="#ampersand-state-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-state-extend" class="anchor" href="#ampersand-state-extend"><h3><span class="header-link"></span>extend <code>AmpersandState.extend({ })</code></h3></a><p>To create a <strong>State</strong> class of your own, you extend <strong>AmpersandState</strong> and provide instance properties and options for your class. Typically here you will pass any properties (<code>props</code>, <code>session</code> and <code>derived</code>) of your state class, and any instance methods to be attached to instances of your class.</p>
<p><strong>extend</strong> correctly sets up the prototype chain, so that subclasses created with <strong>extend</strong> can be further extended as many times as you like.</p>
<p>Definitions like <code>props</code>, <code>session</code>, <code>derived</code> etc will be merged with superclass definitions.</p>
<pre><code class="javascript">var Person = AmpersandState.extend({
    props: {
        firstName: &#39;string&#39;,
        lastName: &#39;string&#39;
    },
    session: {
        signedIn: [&#39;boolean&#39;, true, false],
    },
    derived: {
        fullName: {
            deps: [&#39;firstName&#39;, &#39;lastName&#39;],
            fn: function () {
                return this.firstName + &#39; &#39; + this.lastName;
            }
        }
    }
});
</code></pre>
<p><code>AmpersandState.extend</code> does more than just copy attributes from one prototype to another. As such it is incompatible with Coffeescript&#39;s class-based extend. TypeScript users may have similar issues.</p>
<p>For instance, this will not work since it never actually calls <code>AmpersandState.extend</code>:</p>
<pre><code class="javascript">class Foo extends AmpersandView
     constructor: (options)-&gt;
         @special = options.special
         super
</code></pre>
<a name="ampersand-state-constructorinitialize" class="anchor" href="#ampersand-state-constructorinitialize"><h3><span class="header-link"></span>constructor/initialize <code>new AmpersandState([attrs], [options])</code></h3></a><p>When creating an instance of a state object, you can pass in the initial values of the <strong>attributes</strong> which will be <a href="#ampersand-state-set">set</a> on the state. Unless <a href="#amperand-state-extra-properties">extraProperties</a> is set to <code>allow</code>, you will need to have defined these attributes in <code>props</code> or <code>session</code>.</p>
<p>If you have defined an <code>initialize</code> function for your subclass of State, it will be invoked at creation time.</p>
<pre><code class="javascript">var me = new Person({
    firstName: &#39;Phil&#39;,
    lastName: &#39;Roberts&#39;
});

me.firstName //=&gt; Phil
</code></pre>
<p>Available options:</p>
<ul>
<li><code>[parse]</code> {Boolean} - whether to call the class&#39;s <a href="#ampersand-state-parse">parse</a> function with the initial attributes. <em>Defaults to <code>false</code></em>.</li>
<li><code>[parent]</code> {AmpersandState} - pass a reference to a state&#39;s parent to store on the state.</li>
</ul>
<a name="ampersand-state-idattribute" class="anchor" href="#ampersand-state-idattribute"><h3><span class="header-link"></span>idAttribute <code>state.idAttribute</code></h3></a><p>The attribute that should be used as the unique id of the state. <code>getId</code> uses this to determine the <code>id</code> for use when constructing a model&#39;s <code>url</code> for saving to the server.</p>
<p>Defaults to <code>&#39;id&#39;</code>.</p>
<pre><code class="javascript">var Person = AmpersandModel.extend({
    idAttribute: &#39;personId&#39;,
    urlRoot: &#39;/people&#39;,
    props: {
        personId: &#39;number&#39;,
        name: &#39;string&#39;
    }
});

var me = new Person({ personId: 123 });

console.log(me.url()) //=&gt; &quot;/people/123&quot;
</code></pre>
<a name="ampersand-state-getid" class="anchor" href="#ampersand-state-getid"><h3><span class="header-link"></span>getId <code>state.getId()</code></h3></a><p>Get ID of state per <code>idAttribute</code> configuration. Should <em>always</em> be how ID is determined by other code.</p>
<a name="ampersand-state-namespaceattribute" class="anchor" href="#ampersand-state-namespaceattribute"><h3><span class="header-link"></span>namespaceAttribute <code>state.namespaceAttribute</code></h3></a><p>The property name that should be used as a namespace. Namespaces are completely optional, but exist in case you need to make an additional distinction between states, that may be of the same type, with potentially conflicting IDs but are in fact different.</p>
<p>Defaults to <code>&#39;namespace&#39;</code>.</p>
<a name="ampersand-state-getnamespace" class="anchor" href="#ampersand-state-getnamespace"><h3><span class="header-link"></span>getNamespace <code>state.getNamespace()</code></h3></a><p>Get namespace of state per <code>namespaceAttribute</code> configuration. Should <em>always</em> be how namespace is determined by other code.</p>
<a name="ampersand-state-typeattribute" class="anchor" href="#ampersand-state-typeattribute"><h3><span class="header-link"></span>typeAttribute</h3></a><p>The property name that should be used to specify what type of state this is. This is optional, but specifying a state type types provides a standard, yet configurable way to determine what type of state it is.</p>
<p>Defaults to <code>&#39;modelType&#39;</code>.</p>
<a name="ampersand-state-gettype" class="anchor" href="#ampersand-state-gettype"><h3><span class="header-link"></span>getType <code>state.getType()</code></h3></a><p>Get type of state per <code>typeAttribute</code> configuration. Should <em>always</em> be how type is determined by other code.</p>
<a name="ampersand-state-extraproperties" class="anchor" href="#ampersand-state-extraproperties"><h3><span class="header-link"></span>extraProperties <code>AmpersandState.extend({ extraProperties: &#39;allow&#39; })</code></h3></a><p>Defines how properties that aren&#39;t defined in <code>props</code>, <code>session</code> or <code>derived</code> are handled. May be set to <code>&#39;allow&#39;</code>, <code>&#39;ignore&#39;</code> or <code>&#39;reject&#39;</code>.</p>
<p>Defaults to <code>&#39;ignore&#39;</code>.</p>
<pre><code class="javascript">var StateA = AmpersandState.extend({
    extraProperties: &#39;allow&#39;,
});

var stateA = new StateA({ foo: &#39;bar&#39; });
stateA.foo === &#39;bar&#39; //=&gt; true


var StateB = AmpersandState.extend({
    extraProperties: &#39;ignore&#39;,
});

var stateB = new StateB({ foo: &#39;bar&#39; });
stateB.foo === undefined //=&gt; true


var stateC = AmpersandState.extend({
    extraProperties: &#39;reject&#39;
});

var stateC = new StateC({ foo: &#39;bar&#39; })
//=&gt; TypeError(&#39;No foo property defined on this state and extraProperties not set to &quot;ignore&quot; or &quot;allow&quot;.&#39;);
</code></pre>
<a name="ampersand-state-collection" class="anchor" href="#ampersand-state-collection"><h3><span class="header-link"></span>collection <code>state.collection</code></h3></a><p>A reference to the collection a state is in, if in a collection.</p>
<p>This is used for building the default <code>url</code> property, etc.</p>
<p>Which is why you can do this:</p>
<pre><code class="javascript">// some ampersand-rest-collection instance
// with a `url` property
widgets.url //=&gt; &#39;/api/widgets&#39;

// get a widget from our collection
var badWidget = widgets.get(&#39;47&#39;);

// Without a `collection` reference this
// widget wouldn&#39;t know what URL to build
// when calling destroy
badWidget.destroy(); // does a DELETE /api/widgets/47
</code></pre>
<a name="ampersand-state-cid" class="anchor" href="#ampersand-state-cid"><h3><span class="header-link"></span>cid <code>state.cid</code></h3></a><p>A special property of states, the <strong><code>cid</code></strong>, or a client id, is a unique identifier automatically assigned to all states when they are first created. Client ids are handy when the state has not been saved to the server, and so does not yet have its true <code>id</code>, but needs a unique id (so it can be rendered in the UI, etc.).</p>
<pre><code class="javascript">var userA = new User();
console.log(userA.cid) //=&gt; &quot;state-1&quot;

var userB = new User();
console.log(userB.cid) //=&gt; &quot;state-2&quot;
</code></pre>
<a name="ampersand-state-isnew" class="anchor" href="#ampersand-state-isnew"><h3><span class="header-link"></span>isNew <code>state.isNew()</code></h3></a><p>Has this state been saved to the server yet? If the state does not yet have an <code>id</code> (using <code>getId()</code>), it is considered to be new.</p>
<a name="ampersand-state-escape" class="anchor" href="#ampersand-state-escape"><h3><span class="header-link"></span>escape <code>state.escape()</code></h3></a><p>Similar to <code>get</code>, but returns the HTML-escaped version of a state&#39;s attribute. If you&#39;re interpolating data from the state into HTML, use <code>escape</code> when retrieving attributes to help prevent XSS attacks.</p>
<pre><code class="javascript">var hacker = new PersonModel({
    name: &quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;
});

document.body.innerHTML = hacker.escape(&#39;name&#39;);
</code></pre>
<a name="ampersand-state-isvalid" class="anchor" href="#ampersand-state-isvalid"><h3><span class="header-link"></span>isValid <code>state.isValid()</code></h3></a><p>Check if the state is currently valid. It does this by calling the state&#39;s <code>validate</code> method (if you&#39;ve provided one).</p>
<a name="ampersand-state-datatypes" class="anchor" href="#ampersand-state-datatypes"><h3><span class="header-link"></span>dataTypes  <code>AmpersandState.extend({ datatypes: myCustomTypes })</code></h3></a><p>ampersand-state defines several built-in datatypes:  <code>string</code>, <code>number</code>, <code>boolean</code>, <code>array</code>, <code>object</code>, <code>date</code>, <code>state</code>, or <code>any</code>.  Of these, <code>object</code>, <code>array</code> and <code>any</code> allow for a lot of extra flexibility.  However sometimes it may be useful to define your own custom datatypes. Then you can use these types in the <code>props</code> below with all their features (like <code>required</code>, <code>default</code>, etc).</p>
<p>Setting <code>type</code> is required and <code>typeError</code> will be thrown if it&#39;s missing or has not been choosen either from default types or your custom ones.</p>
<p>To define a type, you generally will provide an object with 4 member functions (though only 2 are usually necessary)  <code>get</code>, <code>set</code>, <code>default</code>, and <code>compare</code>.</p>
<ul>
<li><code>set : function(newVal){};  returns {type : type, val : newVal};</code>:  Called on every set. Should return an object with two members: <code>val</code> and <code>type</code>.  If the <code>type</code> value does not equal the name of the dataType you defined, a <code>TypeError</code> should be thrown.</li>
<li><code>compare : function(currentVal, newVal, attributeName){}; returns boolean</code>:  Called on every <code>set</code>. Should return <code>true</code> if <code>oldVal</code> and <code>newVal</code> are equal.  Non-equal values will eventually trigger <code>change</code> events, unless the state&#39;s <code>set</code> (not the dataTypes&#39;s!) is called with the option <code>{silent : true}</code>.</li>
<li><code>onChange : function (value, previousValue, attributeName){};</code>: Called after the value changes. Useful for automatically setting up or tearing down listeners on properties.</li>
<li><code>get : function(val){} returns val;</code>:  Overrides the default getter of this type.  Useful if you want to make defensive copies.  For example, the <code>date</code> dataType returns a clone of the internally saved <code>date</code> to keep the internal state consistent.</li>
<li><code>default : function(){} returns val;</code>:  Returns the default value for this type.</li>
</ul>
<p>For example, let&#39;s say your application uses a special type of date, <code>JulianDate</code>.  You&#39;d like to setup this as a type in state, but don&#39;t want to just use <code>any</code> or <code>object</code> as the type.  To define it:</p>
<pre><code class="javascript">// Julian Date is a &#39;class&#39; defined elsewhere:
// it has an &#39;equals&#39; method and takes `{julianDays : number}` as a constructor

var Person = AmpersandState.extend({
   dataTypes : {
        julianDate : {
           // set called every time someone tried to set a property of this datatype
           set : function(newVal){
               if(newVal instanceof JulianDate){
                   return {
                       val : newVal,
                       type : &#39;julianDate&#39;
                   };
               }
               try{
                   // try to parse it from passed in value:
                   var newDate = new JulianDate(newVal);

                   return {
                       val : newDate,
                       type : &#39;julianDate&#39;
                   };
               }catch(parseError){
                   // return the value with what we think its type is
                   return {
                       val : newVal,
                       type : typeof newVal
                   };
               }
           },
           compare : function(currentVal, newVal, attributeName){
               return currentVal.equals(newVal);
           }
       }

   }
   props : {
       bornOn : &#39;julianDate&#39;,
       retiresOn : {
           type : &#39;julianDate&#39;,
           required : &#39;true&#39;,
           default : function(){
                  // assuming an &#39;add&#39; function on julian date which returns a new JulianDate
                  return this.bornOn.add(&#39;60&#39;,&#39;years&#39;);
               }
           }
   }
});

var person = new Person({ bornOn : new JulianDate({julianDays : 1000}); }
// this will also work and will build a new JulianDate
var person = new Person({bornOn : {julianDays : 1000}});

// will construct a new julian date for us
// and will also trigger a change event
person.bornOn = {julianDays : 1001};

// but this will not trigger a change event since the equals method would return true
person.bornOn = {julianDays : 1001};
</code></pre>
<a name="ampersand-state-props" class="anchor" href="#ampersand-state-props"><h3><span class="header-link"></span>props <code>AmpersandState.extend({ props: { name: &#39;string&#39; } })</code></h3></a><p>The <strong><code>props</code></strong> object describes the observable properties of your state class. Always pass <code>props</code> to <code>extend</code>; never set it on an instance, as it won&#39;t define new properties.</p>
<p>Properties can be defined in three different ways:</p>
<ul>
<li>As a string with the expected dataType. One of <code>string</code>, <code>number</code>, <code>boolean</code>, <code>array</code>, <code>object</code>, <code>date</code>, or <code>any</code>. (Example: <code>name: &#39;string&#39;</code>.) Can also be set to the name of a custom <code>dataTypes</code>, if the class defines any.</li>
<li>An array of <code>[dataType, required, default]</code></li>
<li>An object <code>{ type: &#39;string&#39;, required: true, default: &#39;&#39; , values: [], allowNull: false, setOnce: false }</code></li>
<li><code>default</code> will be the value that the property will be set to if it is <code>undefined</code> (either by not being set during initialization, or by being explicit set to <code>undefined</code>).</li>
<li>If <code>required</code> is <code>true</code>, one of two things will happen<ul>
<li>If the property has a <code>default</code>, it will start with that value, and revert to it after a call to <code>unset(propertyName)</code>.</li>
<li>If the property does not have a <code>default</code>, calls to <code>unset(propertyName)</code> will throw an error.</li>
</ul>
</li>
<li>If <code>values</code> array is passed, then you&#39;ll be able to change a property to one of those values only.</li>
<li>If <code>setOnce</code> is <code>true</code>, then you&#39;ll be able to set property only once.<ul>
<li>If the property has a <code>default</code>, and you don&#39;t set the value initially, the property will be permanently set to the default value.</li>
<li>If the property doesn&#39;t have a <code>default</code>, and you don&#39;t set the value initially, it can be set later, but only once.</li>
</ul>
</li>
<li>If <code>test</code> function is passed, then a negative validation test will be executed every time this property is about to be set. If the validation passes, the function must return <code>false</code> to tell <strong>State</strong> to go ahead and set the value. Otherwise, it should return a <code>string</code> with the error message describing the validation failure. In this case <strong>State</strong> will throw a <code>TypeError</code> with <code>&quot;Property &#39;&lt;property&gt;&#39; failed validation with error: &lt;errorMessage&gt;&quot;</code>.</li>
</ul>
<p>Trying to set a property to an invalid type will throw an error.</p>
<p>See <a href="#ampersand-state-get">get</a> and <a href="#ampersand-state-set">set</a> for more information about getting and setting properties.</p>
<pre><code class="javascript">var Person = AmpersandState.extend({
    props: {
        name: &#39;string&#39;,
        age: &#39;number&#39;,
        paying: [&#39;boolean&#39;, true, false], // required attribute, defaulted to false
        type: {
            type: &#39;string&#39;,
            values: [&#39;regular-hero&#39;, &#39;super-hero&#39;, &#39;mega-hero&#39;]
        },
        numberOfChildren: {
            type: &#39;number&#39;,
            test: function(value){
                if (value &lt; 0) {
                    return &quot;Must be a positive number&quot;;
                }
                return false;
            }
        },
    }
});
</code></pre>
<a name="ampersand-state-reserved-prop-session-names" class="anchor" href="#ampersand-state-reserved-prop-session-names"><h4><span class="header-link"></span>reserved prop, session names</h4></a><p>The following should not be used as <code>prop</code> names for any state object. This of course includes things based on state such as ampersand-model and ampersand-view.</p>
<p>If you&#39;re consuming an API you don&#39;t control, you can re-name keys by overwriting <code>parse</code> and <code>serialize</code> methods.</p>
<p><code>bind</code>, <code>changedAttributes</code>, <code>cid</code>, <code>clear</code>, <code>collection</code>, <code>constructor</code>, <code>createEmitter</code>, <code>escape</code>, <code>extraProperties</code>, <code>get</code>, <code>getAttributes</code>, <code>getId</code>, <code>getNamespace</code>, <code>getType</code>, <code>hasChanged</code>, <code>idAttribute</code>, <code>initialize</code>, <code>isNew</code>, <code>isValid</code>, <code>listenTo</code>, <code>listenToAndRun</code>, <code>listenToOnce</code>, <code>namespaceAttribute</code>, <code>off</code>, <code>on</code>, <code>once</code>, <code>parent</code>, <code>parse</code>, <code>previous</code>, <code>previousAttributes</code>, <code>serialize</code>, <code>set</code>, <code>stopListening</code>, <code>toJSON</code>, <code>toggle</code>, <code>trigger</code>, <code>typeAttribute</code>, <code>unbind</code>, <code>unset</code>, <code>url</code></p>
<a name="ampersand-state-defaulting-to-objectsarrays" class="anchor" href="#ampersand-state-defaulting-to-objectsarrays"><h4><span class="header-link"></span>defaulting to objects/arrays</h4></a><p>You will get an error if you try to set the default of any property as either an object or array.  This is because those two dataTypes are mutable and passed by reference.  (Thus, if you <em>did</em> set a property&#39;s default to <code>[&#39;a&#39;,&#39;b&#39;]</code>, it would return <em>the same array</em> on every new instantiation of the state.)</p>
<p>Instead, if you want a property to default to an array or an object, just set <code>default</code> to a function, like this:</p>
<pre><code class="javascript">AmpersandModel.extend({
    props: {
        checkpoints: {
            type: &#39;array&#39;,
            default: function () { return []; }
        }
    }
});
</code></pre>
<p>It&#39;s worth noting that both <code>array</code> and <code>object</code> have this behavior built-in: they default to empty versions of themselves.  You would only need to do this if you wanted to default to an array/object that wasn&#39;t empty.</p>
<a name="ampersand-state-session" class="anchor" href="#ampersand-state-session"><h3><span class="header-link"></span>session <code>AmpersandState.extend({ session: { name: &#39;string&#39; } })</code></h3></a><p>Session properties are defined and work in exactly the same way as <a href="#ampersand-state-props">props</a>, but generally only exist for the lifetime of the page. They would not typically be persisted to the server, and are not returned by calls to <code>toJSON()</code> or <code>serialize()</code>.</p>
<pre><code class="javascript">var Person = AmpersandState.extend({
    props: {
        name: &#39;string&#39;,
    },
    session: {
        isLoggedIn: &#39;boolean&#39;
    }
);
</code></pre>
<a name="ampersand-state-derived" class="anchor" href="#ampersand-state-derived"><h3><span class="header-link"></span>derived <code>AmpersandState.extend({ derived: { derivedProperties }})</code></h3></a><p>Derived properties (also known as computed properties) are properties of the state object that depend on other properties (from <code>props</code>, <code>session</code>,  or even <code>derived</code> or the same from state props or children) to determine their value. Best demonstrated with an example:</p>
<pre><code class="javascript">var Address = AmpersandState.extend({
  props: {
    &#39;street&#39;: &#39;string&#39;,
    &#39;city&#39;: &#39;string&#39;,
    &#39;region&#39;: &#39;string&#39;,
    &#39;postcode&#39;: &#39;string&#39;
  }
});

var Person = AmpersandState.extend({
    props: {
        firstName: &#39;string&#39;,
        lastName: &#39;string&#39;,
        address: &#39;state&#39;
    },
    derived: {
        fullName: {
            deps: [&#39;firstName&#39;, &#39;lastName&#39;],
            fn: function () {
                return this.firstName + &#39; &#39; + this.lastName;
            }
        },
        mailingAddress: {
            deps: [&#39;address.street&#39;, &#39;address.city&#39;, &#39;address.region&#39;, &#39;address.postcode&#39;],
            fn: function () {
                var self = this;
                return [&#39;street&#39;,&#39;city&#39;,&#39;region&#39;,&#39;postcode&#39;].map(function (prop) {
                    var val = self.address[prop];
                    if (!val) return val;
                    return (prop === &#39;street&#39; || prop === &#39;city&#39;) ? val + &#39;,&#39; : val;
                }).filter(function (val) {
                    return !!val;
                }).join(&#39; &#39;);
            }
        }
    }
});

var person = new Person({
    firstName: &#39;Phil&#39;,
    lastName: &#39;Roberts&#39;,
    address: new Address({
        street: &#39;123 Main St&#39;,
        city: &#39;Anyplace&#39;,
        region: &#39;BC&#39;,
        postcode: &#39;V6A 2S5&#39;
    })
});
console.log(person.fullName) //=&gt; &quot;Phil Roberts&quot;
console.log(person.mailingAddress) //=&gt; &quot;123 Main St, Anyplace, BC V6A 2S5&quot;

person.firstName = &#39;Bob&#39;;
person.address.street = &#39;321 St. Charles Pl&#39;
console.log(person.fullName) //=&gt; &quot;Bob Roberts&quot;
console.log(person.mailingAddress) //=&gt; &quot;321 St. Charles Pl, Anyplace, BC V6A 2S5&quot;
</code></pre>
<p>See working example at <a href="http://requirebin.com/?gist=c496f0d33f32527fe1ca">RequireBin</a></p>
<p>Each derived property is defined as an object with the following properties:</p>
<ul>
<li><code>deps</code> {Array} - An array of property names which the derived property depends on.</li>
<li><code>fn</code> {Function} - A function which returns the value of the computed property. It is called in the context of the current object, so that <code>this</code> is set correctly.</li>
<li><code>cache</code> {Boolean} - Whether to cache the property. Uncached properties are computed everytime they are accessed. Useful if it depends on the current time for example. <em>Defaults to <code>true</code></em>.</li>
</ul>
<p>Derived properties are retrieved and fire <code>change</code> events just like any other property. However, they cannot be set directly. Caching ensures that the <code>fn</code> function is only run when any of the dependencies change, and <code>change</code> events are only fired if the result of calling <code>fn()</code> has actually changed.</p>
<a name="ampersand-state-children" class="anchor" href="#ampersand-state-children"><h3><span class="header-link"></span>children <code>AmpersandState.extend({ children: { profile: Profile } })</code></h3></a><p>Define child state objects to attach to the object. Attributes passed to the constructor or to <code>set()</code> will be proxied to the children/collections. Childen&#39;s <code>change</code> events are proxied to the parent.</p>
<pre><code class="javascript">var AmpersandState = require(&#39;ampersand-state&#39;);
var Hat = AmpersandState.extend({
    props: {
        color: &#39;string&#39;
    }
});

var Person = AmpersandState.extend({
    props: {
        name: &#39;string&#39;
    },
    children: {
        hat: Hat
    }
});

var me = new Person({ name: &#39;Phil&#39;, hat: { color: &#39;red&#39; } });

me.on(&#39;all&#39;, function (eventName) {
    console.log(&#39;Got event: &#39;, eventName);
});

console.log(me.hat) //=&gt; Hat{color: &#39;red&#39;}

me.set({ hat: { color: &#39;green&#39; } });
//-&gt; &quot;Got event: change:hat.color&quot;
//-&gt; &quot;Got event: change&quot;

console.log(me.hat) //=&gt; Hat{color: &#39;green&#39;}
</code></pre>
<p><strong>note:</strong> If you want to be able to swap out and get a <code>change</code> event from a child model, don&#39;t use <code>children</code> instead, define a prop in <code>props</code> of type <code>state</code>.</p>
<p><code>children</code> and <code>collections</code> are not just a property of the parent, they&#39;re <em>part</em> of the parent. When you create the parent, an instance of any children or collections will be instantiated as part of instantiating the parent, whether they have any data or not.</p>
<p>Calling <code>.set()</code> on the parent with a nested object will automatically <code>set()</code> them on children and collections too. This is super handy for APIs <a href="https://developer.github.com/v3/repos/#response">like this one</a> that return nested JSON structures.</p>
<p>Also, there will be no <code>change</code> events triggered if you replace a child with something else after you&#39;ve instantiated the parent because it&#39;s not a true property in the <code>props</code> sense. If you need a prop that stores a state instance, define it as such, don&#39;t use <code>children</code>.</p>
<p>The distinction is important because without it, the following would be problematic:</p>
<pre><code class="javascript">var Person = State.extend({
    props: {
        child: {
            type: &#39;state&#39;
        }
    }
});

var person = new Person()

// throws type error because `{}` isn&#39;t a state object
person.child = {};
// should this work? What should happen if the `child` prop isn&#39;t defined yet?
person.set({child: {name: &#39;mary&#39;}});
</code></pre>
<p>So, while having <code>children</code> in addition to props of type <code>state</code> may feel redundant they both exist to help disambiguate how they&#39;re meant to be used.</p>
<a name="ampersand-state-collections" class="anchor" href="#ampersand-state-collections"><h3><span class="header-link"></span>collections <code>AmpersandState.extend({ collections: { widgets: Widgets } })</code></h3></a><p>Define child collection objects to attach to the object. Attributes passed to the constructor or to <code>set()</code> will be proxied to the collections.</p>
<p><strong>Note:</strong> Currently, events <em>don&#39;t</em> automatically proxy from collections to parent. This is for efficiency reasons. But there are ongoing discussions about how to best handle this.</p>
<pre><code class="javascript">var State = require(&#39;ampersand-state&#39;);
var Collection = require(&#39;ampersand-collection&#39;);

var Widget = State.extend({
    props: {
        name: &#39;string&#39;,
        funLevel: &#39;number&#39;
    }
});

var WidgetCollection = Collection.extend({
    model: Widget
});

var Person = AmpersandState.extend({
    props: {
        name: &#39;string&#39;
    },
    collections: {
        widgets: WidgetCollection
    }
});

var me = new Person({
    name: &#39;Henrik&#39;,
    widgets: [
        { name: &#39;rc car&#39;, funLevel: 8 },
        { name: &#39;skis&#39;, funLevel: 11 }
    ]
});

console.log(me.widgets.length); //=&gt; 2
console.log(me.widgets instanceof WidgetCollection); //=&gt; true
</code></pre>
<a name="ampersand-state-parse" class="anchor" href="#ampersand-state-parse"><h3><span class="header-link"></span>parse</h3></a><p><strong>parse</strong> is called when the state is initialized, allowing the attributes to be modified, remapped, renamed, etc., before they are actually applied to the state. In ampersand-state, <code>parse</code> is only called when the state is initialized, and <em>only</em> if <code>{ parse: true }</code> is passed to the constructor&#39;s options:</p>
<pre><code class="javascript">var Person = AmpersandState.extend({
    props: {
        id: &#39;number&#39;,
        name: &#39;string&#39;
    },

    parse: function (attrs) {
        attrs.id = attrs.personID; //remap an oddly named attribute
        delete attrs.personID;

        return attrs;
    }
});

var me = new Person({ personID: 123, name: &#39;Phil&#39; },{ parse: true});

console.log(me.id) //=&gt; 123
console.log(me.personID) //=&gt; undefined
</code></pre>
<p><strong>parse</strong> is arguably more useful in ampersand-model, where data typically comes from the server.</p>
<a name="ampersand-state-serialize" class="anchor" href="#ampersand-state-serialize"><h3><span class="header-link"></span>serialize <code>state.serialize([options])</code></h3></a><p>Serialize the state object into a plain object, ready for sending to the server (typically called via <a href="#ampersand-state-tojson">toJSON</a>). By default, of the state&#39;s properties only <code>props</code> is returned, while <code>session</code> and <code>derived</code> are omitted.  You can serialize  <code>session</code> or <code>derived</code> attributes as well by passing in a options object.  The options object should match that accepted by <code>.getAttributes(...)</code>. This method will also serialize any <code>children</code> or <code>collections</code> by calling their serialize methods.</p>
<a name="ampersand-state-get" class="anchor" href="#ampersand-state-get"><h3><span class="header-link"></span>get <code>state.get(attribute); state[attribute]; state.firstName</code></h3></a><p>Get the current value of an attribute from the state object. Attributes can be accessed directly, or a call to the Backbone style <code>get</code>. So these are all equivalent:</p>
<pre><code class="javascript">person.get(&#39;firstName&#39;);
person[&#39;firstName&#39;];
person.firstName
</code></pre>
<p>Get will retrieve <code>props</code>, <code>session</code> or <code>derived</code> properties all in the same way.</p>
<a name="ampersand-state-set" class="anchor" href="#ampersand-state-set"><h3><span class="header-link"></span>set <code>state.set(attributes, [options]); state.firstName = &#39;Henrik&#39;;</code></h3></a><p>Sets an attribute, or multiple attributes, on the state object. If any of the state object&#39;s attributes change, it will trigger a <code>&quot;change&quot;</code> event. Change events for specific attributes are also triggered, which you can listen to as well. For example: <code>&quot;change:firstName&quot;</code> and <code>&quot;change:content&quot;</code>. If the changes update any <code>derived</code> properties on the object, their values will be updated, and change events fired as well.</p>
<p>Attributes can be set directly, or via a call to the backbone style <code>set</code> (useful if you wish to update multiple attributes at once):</p>
<pre><code class="javascript">person.set({firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39;});
person.set(&#39;firstName&#39;, &#39;Phil&#39;);
person.firstName = &#39;Phil&#39;;
</code></pre>
<p>Possible options (when using <code>state.set()</code>):</p>
<ul>
<li><code>silent</code> {Boolean} - prevents triggering of any change events as a result of the set operation.</li>
<li><code>unset</code> {Boolean} - <code>unset</code> the attributes keyed in the attributes object instead of setting them.</li>
</ul>
<p><em>Note: when passing an object as the <code>attributes</code> argument, only that object&#39;s own enumerable properties (i.e. those that can be accessed with <code>Object.keys(object)</code>) are read and set. This behaviour is new as of v5.0.0, as prior version relied on <code>for...in</code> to access an object&#39;s properties, both owned by that object and those inherited through the prototypal chain.</em></p>
<a name="ampersand-state-unset" class="anchor" href="#ampersand-state-unset"><h3><span class="header-link"></span>unset <code>state.unset(attribute|attributes[], [options])</code></h3></a><p>Clear the named attribute or an array of named attributes from the state object. Fires a <code>&quot;change&quot;</code> event and a <code>&quot;change:attributeName&quot;</code> event unless <code>silent</code> is passed as an option.</p>
<p>If the attribute being unset is <code>required</code> and has a <code>default</code> value as defined in either <code>props</code> or <code>session</code>, it will be set to that value, otherwise it will be <code>undefined</code>.</p>
<pre><code class="javascript">// unset a single attribute
person.unset(&#39;firstName&#39;)
</code></pre>
<pre><code class="javascript">// unset multiple attributes
person.unset([&#39;firstName&#39;, &#39;lastName&#39;])
</code></pre>
<a name="ampersand-state-clear" class="anchor" href="#ampersand-state-clear"><h3><span class="header-link"></span>clear <code>state.clear([options])</code></h3></a><p>Clear all the attributes from the state object, by calling the <code>unset</code> function for each attribute, with the options provided.</p>
<pre><code class="javascript">person.clear()
</code></pre>
<a name="ampersand-state-toggle" class="anchor" href="#ampersand-state-toggle"><h3><span class="header-link"></span>toggle <code>state.toggle(&#39;a&#39;)</code></h3></a><p>Shortcut to toggle boolean properties, or cycle through array of specified property&#39;s <code>values</code> (see <code>values</code> option section and example below).
When you reach the last available value from given array, <code>toggle</code> will go back to the beginning and use first one.</p>
<p>Fires <code>&quot;change&quot;</code> events, as you would expect from <code>set()</code>.</p>
<pre><code class="javascript">var Person = AmpersandState.extend({
    props: {
        active: &#39;boolean&#39;,
        color: {
            type: &#39;string&#39;,
            values: [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
        }
    }
});

var me = new Person({ active: true, color: &#39;green&#39; });

me.toggle(&#39;active&#39;);
console.log(me.active) //=&gt; false

me.toggle(&#39;color&#39;);
console.log(me.color) //=&gt; &#39;blue&#39;

me.toggle(&#39;color&#39;);
console.log(me.color) //=&gt; &#39;red&#39;
</code></pre>
<a name="ampersand-state-previousattributes" class="anchor" href="#ampersand-state-previousattributes"><h3><span class="header-link"></span>previousAttributes <code>state.previousAttributes()</code></h3></a><p>Return a copy of the object&#39;s previous attributes (the state before the last <code>&quot;change&quot;</code> event). Useful for getting a diff between versions of a state, or getting back to a valid state after an error occurs.</p>
<a name="ampersand-state-haschanged" class="anchor" href="#ampersand-state-haschanged"><h3><span class="header-link"></span>hasChanged <code>state.hasChanged([attribute])</code></h3></a><p>Determine if the state has been modified since the last <code>&quot;change&quot;</code> event. If an attribute name is passed, determine if that one attribute has changed.</p>
<p><strong>note:</strong> that this will only be <code>true</code> if checked inside a handler while the various <code>change</code> events are firing. Once the change events are done this will always return <code>false</code>. This has nothing to do with determining whether a property has changed since the last time it was saved to the server.</p>
<a name="ampersand-state-changedattributes" class="anchor" href="#ampersand-state-changedattributes"><h3><span class="header-link"></span>changedAttributes <code>state.changedAttributes([objectToDiff])</code></h3></a><p>Return an object containing all the attributes that have changed, or <code>false</code> if there are no changed attributes. Useful for determining what parts of a view need to be updated and/or what attributes need to be persisted to the server. Unset attributes will be set to undefined.  You can also pass an attributes object to diff against the state, determining if there <em>would be</em> a change.</p>
<p><strong>note:</strong> that if passing an attributes object to diff against, only changes to properties defined on the model will be detected. This means that changes to children or collections will <em>not</em> be returned as changes by this method.</p>
<p><strong>note:</strong> that this will only return values if checked inside a handler while the various <code>change</code> events are firing. Once the change events are done this will always be return an empty object. This has nothing to do with determining which properties have been changed since the last time it was saved to the server.</p>
<a name="ampersand-state-tojson" class="anchor" href="#ampersand-state-tojson"><h3><span class="header-link"></span>toJSON <code>state.toJSON()</code></h3></a><p>Return a shallow copy of the state&#39;s attributes for JSON stringification. This can be used for persistence, serialization, or augmentation, before being sent to the server. The name of this method is a bit confusing, as it doesn&#39;t actually return a JSON string  but I&#39;m afraid that it&#39;s the way that the JavaScript API for <code>JSON.stringify</code> works.</p>
<p>Calls <a href="#ampersand-state-serialize">serialize</a> to determine which values to return in the object. Will be called implicitly by <code>JSON.stringify</code>.</p>
<pre><code class="javascript">var me = new Person({ firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39; });

me.toJSON() //=&gt; { firstName: &#39;Phil&#39;, lastName: &#39;Roberts&#39; }

//JSON.stringify implicitly calls toJSON:
JSON.stringify(me) //=&gt; &quot;{\&quot;firstName\&quot;:\&quot;Phil\&quot;,\&quot;lastName\&quot;:\&quot;Roberts\&quot;}&quot;
</code></pre>
<a name="ampersand-state-getattributes" class="anchor" href="#ampersand-state-getattributes"><h3><span class="header-link"></span>getAttributes <code>state.getAttributes([options, raw])</code></h3></a><p>Returns a shallow copy of the state&#39;s attributes while only including the types (props, session, derived) specified by the <code>options</code> parameter. The desired keys should be set to <code>true</code> on <code>options</code> (<code>props</code>, <code>session</code>, <code>derived</code>) if attributes of that type should be returned by <code>getAttributes</code>.</p>
<p>The second parameter, <code>raw</code>, is a boolean that specifies whether returned values should be the raw value or should instead use the getter associated with its data type. If you are using <code>getAttributes</code> to pass data to a template, most of the time you will not want to use the <code>raw</code> parameter, since you will want to take advantage of any built-in and custom data types on your state instance.</p>
<pre><code class="javascript">var Person = AmpersandState.extend({
  props: {
      firstName: &#39;string&#39;,
      lastName: &#39;string&#39;
  },
  session: {
    lastSeen: &#39;date&#39;,
    active: &#39;boolean&#39;
  },
  derived: {
    fullName: {
      deps: [&#39;firstName&#39;, &#39;lastName&#39;],
      fn: function () {
        return this.firstName + &#39; &#39; + this.lastName;
      }
    }
  }
});

var me = new Person({ firstName: &#39;Luke&#39;, lastName: &#39;Karrys&#39;, active: true, lastSeen: 1428430444479 });

me.getAttributes({derived: true}) //=&gt; { fullName: &#39;Luke Karrys&#39; }

me.getAttributes({session: true}) //=&gt; { active: true, lastSeen: Tue Apr 07 2015 11:14:04 GMT-0700 (MST) }
me.getAttributes({session: true}, true) //=&gt; { active: true, lastSeen: 1428430444479 }

me.getAttributes({
  props: true,
  session: true,
  derived: true
}) //=&gt; { firstName: &#39;Luke&#39;, lastName: &#39;Karrys&#39;, active: true, lastSeen: Tue Apr 07 2015 11:14:04 GMT-0700 (MST), fullName: &#39;Luke Karrys&#39; }
</code></pre>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-model/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-model" href="#ampersand-model" class="anchor">
            <h1><span class="header-link"></span>ampersand-model</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-model</h4>
            <p class="module-version">latest v6.0.2</p>
            <p class="module-description">An extension to ampersand-state that adds methods and properties for working with a RESTful API.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-model">github</a><a href="https://www.npmjs.org/package/ampersand-model">npm</a></p>
          </div>
          <div><p>ampersand-model is an extension built on <a href="http://ampersandjs.com/docs/#ampersand-state">ampersand-state</a> to provide methods and properties that you&#39;ll often want when modeling data you get from an API.</p>
<p>For further explanation see the <a href="http://ampersandjs.com/learn/state">learn ampersand-state</a> guide.</p>
<a name="ampersand-model-installing" class="anchor" href="#ampersand-model-installing"><h2><span class="header-link"></span>Installing</h2></a><pre><code>npm install ampersand-model
</code></pre><a name="ampersand-model-observing" class="anchor" href="#ampersand-model-observing"><h2><span class="header-link"></span>Observing</h2></a><p>Ampersand gets its event system from Backbone using the <a href="https://www.npmjs.org/package/backbone-events-standalone">backbone-events-standalone</a> module on npm.</p>
<p>For more, <a href="http://ampersandjs.com/learn/events">read all about how events work in ampersand</a>.</p>
<a name="ampersand-model-api-reference" class="anchor" href="#ampersand-model-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><p>The module exports just one item, the ampersand-model constructor. It has a method called <code>extend</code> that works as follows:</p>
<a name="ampersand-model-extend" class="anchor" href="#ampersand-model-extend"><h3><span class="header-link"></span>extend <code>AmpersandModel.extend({ })</code></h3></a><p>To create a <strong>Model</strong> class of your own, you extend <strong>AmpersandModel</strong> and provide instance properties and options for your class. Typically here you will pass any properties (<code>props</code>, <code>session</code>, and <code>derived</code>) of your model class, and any instance methods to be attached to instances of your class.</p>
<p><strong>extend</strong> correctly sets up the prototype chain, so that subclasses created with <strong>extend</strong> can be further extended as many times as you like.</p>
<p>As with AmpersandState, definitions like <code>props</code>, <code>session</code>, <code>derived</code> etc will be merged with superclass definitions.</p>
<pre><code class="javascript">var Person = AmpersandModel.extend({
    props: {
        firstName: &#39;string&#39;,
        lastName: &#39;string&#39;
    },
    session: {
        signedIn: [&#39;boolean&#39;, true, false],
    },
    derived: {
        fullName: {
            deps: [&#39;firstName&#39;, &#39;lastName&#39;],
            fn: function () {
                return this.firstName + &#39; &#39; + this.lastName;
            }
        }
    }
});
</code></pre>
<a name="ampersand-model-constructorinitialize" class="anchor" href="#ampersand-model-constructorinitialize"><h3><span class="header-link"></span>constructor/initialize <code>new ExtendedAmpersandModel([attrs], [options])</code></h3></a><p>This works exactly like <a href="http://ampersandjs.com/docs/#ampersand-state-constructorinitialize">state</a> with a minor addition: If you pass a <code>collection</code> as part of options it&#39;ll be stored for reference.</p>
<p>As with AmpersandState, if you have defined an <strong>initialize</strong> function for your subclass of State, it will be invoked at creation time.</p>
<pre><code class="javascript">var me = new Person({
    firstName: &#39;Phil&#39;,
    lastName: &#39;Roberts&#39;
});

me.firstName //=&gt; Phil
</code></pre>
<p>Available options:</p>
<ul>
<li><code>[parse]</code> {Boolean} - whether to call the class&#39;s <a href="#ampersand-state-parse">parse</a> function with the initial attributes. <em>Defaults to <code>false</code></em>.</li>
<li><code>[parent]</code> {AmpersandState} - pass a reference to a model&#39;s parent to store on the model.</li>
<li><code>[collection]</code> {Collection} - pass a reference to the collection the model is in. Defaults to <code>undefined</code>.</li>
</ul>
<a name="ampersand-model-save" class="anchor" href="#ampersand-model-save"><h3><span class="header-link"></span>save <code>model.save([attributes], [options])</code></h3></a><p>Save a model to your database (or alternative persistence layer) by delegating to to <a href="https://github.com/ampersandjs/ampersand-sync">ampersand-sync</a>. Returns a <a href="https://github.com/Raynos/xhr">xhr</a> object if validation is successful and false otherwise. The attributes hash (as in <a href="http://ampersandjs.com/docs#ampersand-state-set">set</a>) should contain the attributes you&#39;d like to change  keys that aren&#39;t mentioned won&#39;t be altered  but, a <em>complete representation</em> of the resource will be sent to the server. As with <code>set</code>, you may pass individual keys and values instead of a hash. If the model has a validate method, and validation fails, the model will not be saved. If the model <code>isNew</code>, the save will be a &quot;create&quot; (HTTP POST).  If the model already exists on the server, the save will be an &quot;update&quot; (HTTP PUT).</p>
<p>If you only want the changed attributes to be sent to the server, call <code>model.save(attrs, {patch: true})</code>. You&#39;ll get an HTTP PATCH request to the server with just the passed-in attributes.</p>
<p>Calling save with new attributes will cause a <code>&quot;change&quot;</code> event immediately, a <code>&quot;request&quot;</code> event as the Ajax request begins to go to the server, and a <code>&quot;sync&quot;</code> event after the server has acknowledged the successful change. Pass <code>{wait: true}</code> if you&#39;d like to wait for the server before setting the new attributes on the model.</p>
<pre><code class="javascript">var book = new Backbone.Model({
  title: &quot;The Rough Riders&quot;,
  author: &quot;Theodore Roosevelt&quot;
});

book.save();
//=&gt; triggers a `POST` via ampersand-sync with { &quot;title&quot;: &quot;The Rough Riders&quot;, &quot;author&quot;: &quot;Theodore Roosevelt&quot; }

book.save({author: &quot;Teddy&quot;});
//=&gt; triggers a `PUT` via ampersand-sync with { &quot;title&quot;: &quot;The Rough Riders&quot;, &quot;author&quot;: &quot;Teddy&quot; }
</code></pre>
<p><strong>save</strong> accepts <code>success</code> and <code>error</code> callbacks in the options hash, which will be passed the arguments <code>(model, response, options)</code>. If a server-side validation fails, return a non-<code>200</code> HTTP response code, along with an error response in text or JSON.</p>
<a name="ampersand-model-fetch" class="anchor" href="#ampersand-model-fetch"><h3><span class="header-link"></span>fetch <code>model.fetch([options])</code></h3></a><p>Resets the model&#39;s state from the server by delegating a GET to ampersand-sync. Returns a xhr. Useful if the model has yet to be populated with data, or you want to ensure you have the latest server state. A <code>&quot;change&quot;</code> event will be triggered if the retrieved state from the server differs from the current attributes. Accepts <code>success</code> and <code>error</code> callbacks in the options hash, which are both passed <code>(model, response, options)</code> as arguments.</p>
<pre><code class="javascript">var me = new Person({id: 123});
me.fetch();
</code></pre>
<a name="ampersand-model-destroy" class="anchor" href="#ampersand-model-destroy"><h3><span class="header-link"></span>destroy <code>model.destroy([options])</code></h3></a><p>Destroys the model on the server by delegating a HTTP <code>DELETE</code> request to ampersand-sync. Returns the xhr object, or <code>false</code> if the model <a href="#ampersand-model-isnew">isNew</a>. Accepts <code>success</code> and <code>error</code> callbacks in the options hash, which are both passed <code>(model, response, options)</code> as arguments.</p>
<p>Triggers:</p>
<ul>
<li>a <code>&quot;destroy&quot;</code> event on the model, which will bubble up through any collections which contain it.</li>
<li>a <code>&quot;request&quot;</code> event as it begins the Ajax request to the server</li>
<li>a <code>&quot;sync&quot;</code> event, after the server has successfully acknowledged the model&#39;s deletion.</li>
</ul>
<p>Pass <code>{wait: true}</code> if you&#39;d like to wait for the server to respond before removing the model from the collection.</p>
<pre><code class="javascript">var task = new Task({id: 123});
task.destroy({
    success: function () {
        alert(&#39;Task destroyed!&#39;);
    },
    error: function () {
        alert(&#39;There was an error destroying the task&#39;);
    },
});
</code></pre>
<a name="ampersand-model-sync" class="anchor" href="#ampersand-model-sync"><h3><span class="header-link"></span>sync <code>model.sync(method, model, [options])</code></h3></a><p>Uses ampersand-sync to persist the state of a model to the server. Usually you won&#39;t call this directly, you&#39;d use <code>save</code> or <code>destroy</code> instead, but it can be overriden for custom behaviour.</p>
<a name="ampersand-model-configuring" class="anchor" href="#ampersand-model-configuring"><h2><span class="header-link"></span>Configuring</h2></a><a name="ampersand-model-ajaxconfig" class="anchor" href="#ampersand-model-ajaxconfig"><h3><span class="header-link"></span>ajaxConfig <code>model.ajaxConfig or model.ajaxConfig()</code></h3></a><p>ampersand-sync will call ajaxConfig on your model before it makes the request to the server, and will merge in any options you return to the request. When extending your own model, set an ajaxConfig function to modify the request before it goes to the server.</p>
<p>ajaxConfig can either be an object, or a function that returns an object, with the following options:</p>
<ul>
<li><code>useXDR</code> [boolean]: (applies to IE9 only with cross domain requests): signifies that this is a cross-domain request and that IE should use its XDomainRequest object. This is required if you&#39;re making cross-domain requests and want to support IE9). Note that XDR doesn&#39;t support headers/withCredentials.</li>
<li><code>headers</code> [object]: any extra headers to send with the request.</li>
<li><code>xhrFields</code> [object]: any fields to set directly on the <a href="https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest">XHR</a> request object, most typically:<ul>
<li><code>withCredentials</code> [boolean]: whether to send cross domain requests with authorization headers/cookies. Useful if you&#39;re making cross sub-domain requests with a root-domain auth cookie.</li>
</ul>
</li>
<li><code>beforeSend</code> [function]: beforeSend will be called before the request is made, and will be passed the raw <code>xhr</code> object if you wish to modify it directly before it&#39;s sent.</li>
</ul>
<pre><code class="javascript">var Person = AmpersandModel.extend({
    urlRoot: &#39;http://otherdomain.example.com/people&#39;,

    ajaxConfig: function () {
        return {
            headers: {
                &#39;Access-Token&#39;: this.accessToken
            },
            xhrFields: {
                &#39;withCredentials&#39;: true
            }
        };
    }
});

var me = new Person({ id: 123 });
me.fetch();
</code></pre>
<a name="ampersand-model-url" class="anchor" href="#ampersand-model-url"><h3><span class="header-link"></span>url <code>model.url or model.url()</code></h3></a><p>The relative url that the model should use to edit the resource on the server.  By default, <code>url</code> is constructed by sniffing for the model&#39;s <code>urlRoot</code> or the model&#39;s collection <code>url</code>, if present, then appending the <code>idAttribute</code> if the model has not yet been saved.  However, if the model does not follow normal REST endpoint conventions, you may overwrite it.  In such a case, <code>url</code> may be absolute.</p>
<pre><code class="javascript">// overwrite `url()` example
var Person = AmpersandModel.extend({
    props: {
        id: &#39;number&#39;,
        name: &#39;string&#39;
    },
    url: function() {
        var base = _.result(this, &quot;urlRoot&quot;);
        if (this.isNew()) return base;
        return base + &#39;/&#39; + someCustomActionOnServerId(this.getId());
    },
    urlRoot: function() {
        return &#39;/api/&#39; + me.apiVersion + &#39;/persons&#39;;
    }
});

var bob = new Person({id: 1234, name: &#39;bob&#39;});
console.log(bob.urlRoot()); //=&gt; /api/v1/persons
console.log(bob.url()); //=&gt; /api/v1/persons/some/CustomId-bob-1234
</code></pre>
<a name="ampersand-model-urlroot" class="anchor" href="#ampersand-model-urlroot"><h3><span class="header-link"></span>urlRoot <code>model.urlRoot or model.urlRoot()</code></h3></a><p>The base url to use for fetching this model. This is useful if the model is <em>not</em> in a collection and you still want to set a fixed &quot;root&quot; but have a dynamic model.url(). Can also be a function.</p>
<p>If your model is in a collection that has a <code>url</code> you won&#39;t need this, because the model will try to build the URL from its collection.</p>
<pre><code class="javascript">var Person = AmpersandModel.extend({
    props: {
        id: &#39;string&#39;,
        name: &#39;string&#39;
    },
    urlRoot: &#39;/api/persons&#39;
});

var bob = new Person({id: &quot;1234&quot;});

console.log(bob.url()); //=&gt; &quot;/api/persons/1234&quot;
</code></pre>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-collection/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-collection" href="#ampersand-collection" class="anchor">
            <h1><span class="header-link"></span>ampersand-collection</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-collection</h4>
            <p class="module-version">latest v1.6.1</p>
            <p class="module-description">A way to store/manage objects or models.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-collection">github</a><a href="https://www.npmjs.org/package/ampersand-collection">npm</a></p>
          </div>
          <div><p>A way to store/manage objects or models.</p>
<p>Unlike other tools this makes no assumptions about how it&#39;s going to be used or what type of models it is going to contain. This makes it a very flexible/useful tool for modeling all kinds of stuff.</p>
<p>It does not require underscore or jQuery, but instead makes it easy to extend with those methods if you&#39;d like.</p>
<a name="ampersand-collection-installation" class="anchor" href="#ampersand-collection-installation"><h2><span class="header-link"></span>Installation</h2></a><pre><code>npm i ampersand-collection
</code></pre><a name="ampersand-collection-api-reference" class="anchor" href="#ampersand-collection-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-collection-extend" class="anchor" href="#ampersand-collection-extend"><h3><span class="header-link"></span>extend <code>AmpersandCollection.extend([attributes])</code></h3></a><p>Create a collection class of your own by extending <code>AmpersandCollection</code>, providing the required instance properties to be attached instances of your class.</p>
<p>Typically you will specify a <code>model</code> constructor (if you are storing <a href="http://ampersandjs.com/docs#ampersand-state">ampersand-state</a> or <a href="http://ampersandjs.com/docs#ampersand-model">ampersand-model</a> objects).</p>
<a name="ampersand-collection-model" class="anchor" href="#ampersand-collection-model"><h3><span class="header-link"></span>model <code>collection.model</code></h3></a><p>Override this property to specify the model class that the collection contains. If defined, you can pass raw attributes objects (and arrays) to <code>add</code> and <code>reset</code>, and the attributes will be converted into a model of the proper type.</p>
<pre><code class="javascript">var Library = AmpersandCollection.extend({
    model: Book
});
</code></pre>
<p>A collection can also contain polymorphic models by overriding this property with a function that returns a model.</p>
<p><em>Please note</em> that if you do this, you&#39;ll also want to override the <code>isModel</code> method with your own, and describe the logic used to determine whether an object is already an instantiated model or not.</p>
<pre><code class="javascript">var Library = AmpersandCollection.extend({

  model: function(attrs, options) {
    if (condition) {
      return new PublicDocument(attrs, options);
    } else {
      return new PrivateDocument(attrs, options);
    }
  },

  isModel: function (model) {
    return model instanceof PublicDocument || model instanceof PrivateDocument;
  }

});
</code></pre>
<a name="ampersand-collection-constructorinitialize" class="anchor" href="#ampersand-collection-constructorinitialize"><h3><span class="header-link"></span>constructor/initialize <code>new AmpersandCollection([models [, options]])</code></h3></a><p>When creating an <code>AmpersandCollection</code>, you may choose to pass in the initial array of <strong><code>models</code></strong>. The collection&#39;s <a href="#comparator"><code>comparator</code></a> may be included as an option. If you define an <strong><code>initialize</code></strong> function, it will be invoked when the collection is created, with <strong><code>models</code></strong> and <strong><code>options</code></strong> as arguments. There are a couple of options that, if provided, are attached to the collection directly: <code>model</code>, <code>comparator</code> and <code>parent</code>. </p>
<pre><code class="javascript">var people = new AmpersandCollection([{ name: &#39;phil&#39; }, { name: &#39;bob&#39; }, { name: &#39;jane&#39; }], {
    model: Person
});
</code></pre>
<a name="ampersand-collection-mainindex" class="anchor" href="#ampersand-collection-mainindex"><h3><span class="header-link"></span>mainIndex <code>collection.mainIndex</code></h3></a><p>Specify which property the collection should use as the main index (and unique identifier) for the models/objects it holds. This is the property that <a href="#ampersand-collection-get"><code>get</code></a> uses to retrieve models, and what <code>add</code>, <code>set</code>, and <code>remove</code> uses to determine whether a collection already contains a model or not.</p>
<p>If you specify a <a href="http://ampersandjs.com/docs#ampersand-collection-model"><code>model</code></a> property in the collection, and the model specifies an <a href="http://ampersandjs.com/docs#ampersand-state-idattribute"><code>idAttribute</code></a>, the collection will use <em>that</em> as the <code>mainIndex</code> unless you explicitly set it to something else.</p>
<p>If <em>no</em> <code>mainIndex</code> or <code>model</code> is specified <code>&quot;id&quot;</code> is used as the default <code>mainIndex</code>.</p>
<p>This means, that <em>most</em> of the time you don&#39;t need to set <code>mainIndex</code> and things will still Just Work.  If you wish to index on a derived property, your derived <code>fn</code> must be a pure function, and will be bound to the object passed into the collection on <code>.add()/.remove()/.set()</code> etc.</p>
<p>You may set it explicitly while extending <code>AmpersandCollection</code> like so:</p>
<pre><code class="javascript">var People = AmpersandCollection.extend({
    mainIndex: &#39;_id&#39;
});
</code></pre>
<a name="ampersand-collection-indexes" class="anchor" href="#ampersand-collection-indexes"><h3><span class="header-link"></span>indexes <code>collections.indexes</code></h3></a><p>Specify an optional array of keys to serve as additional indexes for the models in your collection (in addition to <code>mainIndex</code>). This allows you to quickly retrieve models by specifying the key to use with <a href="#ampersand-collection-get"><code>get</code></a>.</p>
<p>Note that <code>get</code> will only ever return a single model, so the values of these indexes should be unique across the models in the collection:</p>
<pre><code class="javascript">var People = AmpersandCollection.extend({
    mainIndex: &#39;_id&#39;,

    indexes: [&#39;otherId&#39;]
});

var people = new People([
    { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; },
    { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
    { _id: 3, otherId: &#39;c&#39;, name: &#39;Henrik&#39; },
    { _id: 4, otherId: &#39;d&#39;, name: &#39;Jenn&#39; }
]);

people.get(1) //=&gt; { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; }

people.get(&#39;b&#39;, &#39;otherId&#39;) //=&gt; { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
</code></pre>
<a name="ampersand-collection-length" class="anchor" href="#ampersand-collection-length"><h3><span class="header-link"></span>length <code>collection.length</code></h3></a><p>Returns the <code>length</code> of the underlying array.</p>
<a name="ampersand-collection-iscollectioninstanceof" class="anchor" href="#ampersand-collection-iscollectioninstanceof"><h3><span class="header-link"></span>isCollection/instanceof <code>collection.isCollection</code></h3></a><p>Because of module deps in npm and browserify, sometimes its possible to end up in a situation where the same <code>collection</code> constructor wasn&#39;t used to build a <code>collection</code> object. As a result, <code>instanceof</code> checks will fail.</p>
<p>To deal with this (because sometimes this is a legitimate scenario), <code>collection</code> simply creates a read-only <code>isCollection</code> property on all collection objects. You can use it to check whether or a not a given object is, in fact, a collection objectno matter what its constructor was.</p>
<a name="ampersand-collection-add" class="anchor" href="#ampersand-collection-add"><h3><span class="header-link"></span>add <code>collection.add(modelOrObject, [options])</code></h3></a><p>Add a model (or an array of models) to the collection, firing an <code>&quot;add&quot;</code> event. If a <a href="#ampersand-collection-model"><code>model</code></a> property is defined, you may also pass raw attributes objects, and have them be vivified as instances of the model. Returns the added models (or preexisting models, if already contained).</p>
<p><strong>Options:</strong></p>
<ul>
<li>Pass <code>{at: index}</code> to splice the model into the collection at the specified index.</li>
<li>If you&#39;re adding models to the collection that it already contains, they&#39;ll be ignored, unless you pass <code>{merge: true}</code>, in which case their attributes will be merged into the corresponding models, firing any appropriate <code>&quot;change&quot;</code> events.</li>
</ul>
<pre><code class="javascript">var ships = new AmpersandCollection();

ships.on(&quot;add&quot;, function(ship) {
  console.log(&quot;Ahoy &quot; + ship.name + &quot;!&quot;);
});

ships.add([
  {name: &quot;Flying Dutchman&quot;},
  {name: &quot;Black Pearl&quot;}
]);

//logs:
//- &quot;Ahoy Flying Dutchman!&quot;
//- &quot;Ahoy Black Pearl!&quot;
</code></pre>
<p>Note that adding the same model (a model with the same <code>id</code>) to a collection more than once is a no-op.</p>
<a name="ampersand-collection-serialize" class="anchor" href="#ampersand-collection-serialize"><h3><span class="header-link"></span>serialize <code>collection.serialize()</code></h3></a><p>Serialize the collection into a plain javascript array, ready for sending to the server (typically called via <a href="#ampersand-collection-tojson"><code>toJSON</code></a>). Also calls <code>serialize()</code> on each model in the collection.</p>
<a name="ampersand-collection-tojson" class="anchor" href="#ampersand-collection-tojson"><h3><span class="header-link"></span>toJSON <code>collection.toJSON()</code></h3></a><p>Returns a plain javascript array of the models in the collection (which are also serialized), ready for sending to the server. The name of this method is a bit confusing, as it doesn&#39;t actually return a JSON string  but I&#39;m afraid that it&#39;s the way that the JavaScript API for <code>JSON.stringify()</code> works.</p>
<pre><code class="javascript">var collection = new AmpersandCollection([
    {name: &quot;Tim&quot;, age: 5},
    {name: &quot;Ida&quot;, age: 26},
    {name: &quot;Rob&quot;, age: 55}
]);

console.log(JSON.stringify(collection));
//=&gt; &quot;[{\&quot;name\&quot;:\&quot;Tim\&quot;,\&quot;age\&quot;:5},{\&quot;name\&quot;:\&quot;Ida\&quot;,\&quot;age\&quot;:26},{\&quot;name\&quot;:\&quot;Rob\&quot;,\&quot;age\&quot;:55}]&quot;
</code></pre>
<a name="ampersand-collection-parse" class="anchor" href="#ampersand-collection-parse"><h3><span class="header-link"></span>parse <code>collection.parse(data, [options])</code></h3></a><p>The parse method gets called if the <code>{parse: true}</code> option is passed when calling <code>collection.set</code> method. By default, <code>parse</code> simply returns the data it was passed, but can be overwritten through <code>.extend</code> to provide any additional parsing logic to extract the array of data that should be stored in the collection. This is most commonly used when processing data coming back from an ajax request. The response from an API may look like this:</p>
<pre><code class="javascript">{
  &quot;limit&quot;: 100,
  &quot;offset&quot;: 0,
  &quot;data&quot;: [
    {&quot;name&quot;: &quot;larry&quot;},
    {&quot;name&quot;: &quot;curly&quot;},
    {&quot;name&quot;: &quot;moe&quot;}
  ]
}
</code></pre>
<p>To extract <code>data</code> you&#39;d define a <code>parse</code> method on the collection as follows, to return the array of data to be stored.</p>
<pre><code class="javascript">var MyCollection = Collection.extend({
    parse: function (response) {
        return response.data;
    }
});
</code></pre>
<p>If you&#39;re using <code>ampersand-rest-collection</code>&#39;s <code>fetch()</code> method, the <code>parse</code> method will be called with the response by default. Also, the options object passed to <code>set()</code> gets passed through as a second argument to allow for conditional parsing logic.</p>
<a name="ampersand-collection-set" class="anchor" href="#ampersand-collection-set"><h3><span class="header-link"></span>set <code>collection.set(models, [options])</code></h3></a><p>The <strong>set</strong> method performs a &quot;smart&quot; update of the collection with the passed list of models:</p>
<ul>
<li>If a model in the list isn&#39;t in the collection, it will be added.</li>
<li>If a model in the list is in the collection already, its attributes will be merged.</li>
<li>If the collection contains any models that aren&#39;t in the list, they&#39;ll be removed.</li>
</ul>
<p>All of the appropriate <code>&quot;add&quot;</code>, <code>&quot;remove&quot;</code>, and <code>&quot;change&quot;</code> events are fired as this happens. If you&#39;d like to customize the behavior, you can disable it with options: <code>{add: false}</code>, <code>{remove: false}</code>, or <code>{merge: false}</code>.</p>
<p>Returns the touched models in the collection.</p>
<pre><code class="javascript">var vanHalen = new AmpersandCollection([eddie, alex, stone, roth]);

vanHalen.set([eddie, alex, stone, hagar]);

// Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for &quot;hagar&quot;.
// Updates any of stone, alex, and eddie&#39;s attributes that may have
// changed over the years.
</code></pre>
<a name="ampersand-collection-get" class="anchor" href="#ampersand-collection-get"><h3><span class="header-link"></span>get <code>collection.get(query, [indexName])</code></h3></a><p>Retrieve a model from the collection by index.</p>
<p>If called without <code>indexName</code> (<code>collection.get(123)</code>), retrieves the model by its <a href="#ampersand-collection-mainindex"><code>mainIndex</code></a> attribute.</p>
<p>Alternatively, specify an <code>indexName</code> to retrieve a model by any of the other listed <a href="#ampersand-collection-indexes"><code>indexes</code></a>.</p>
<pre><code class="javascript">var People = AmpersandCollection.extend({
    mainIndex: &#39;_id&#39;,

    indexes: [&#39;otherId&#39;]
});

var people = new People.add([
    { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; },
    { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
    { _id: 3, otherId: &#39;c&#39;, name: &#39;Henrik&#39; },
    { _id: 4, otherId: &#39;d&#39;, name: &#39;Jenn&#39; }
]);

people.get(1) //=&gt; { _id: 1, otherId: &#39;a&#39;, name: &#39;Phil&#39; }

people.get(&#39;b&#39;, &#39;otherId&#39;) //=&gt; { _id: 2, otherId: &#39;b&#39;, name: &#39;Julie&#39; },
</code></pre>
<a name="ampersand-collection-at" class="anchor" href="#ampersand-collection-at"><h3><span class="header-link"></span>at <code>collection.at(index)</code></h3></a><p>Get a model from a collection, specified by <code>index</code>. Useful if your collection is sorted.</p>
<p>If your collection isn&#39;t sorted, <code>at()</code> will still retrieve models in insertion order; e.g., <code>collection.at(0)</code> returns the first model in the collection.</p>
<a name="ampersand-collection-remove" class="anchor" href="#ampersand-collection-remove"><h3><span class="header-link"></span>remove <code>collection.remove(models, [options])</code></h3></a><p>Remove a model (or an array of models) from the collection, and returns them. Fires a <code>&quot;remove&quot;</code> event, which you can use the option <code>{ silent: true }</code> to suppress. The model&#39;s index before removal is available to listeners as <code>options.index</code>.</p>
<p>The models object/array can be references to actual models, or just a list of <code>id</code>s to remove.</p>
<a name="ampersand-collection-reset" class="anchor" href="#ampersand-collection-reset"><h3><span class="header-link"></span>reset <code>collection.reset(models, [options])</code></h3></a><p>Adding and removing models one at a time is all well and good, but sometimes there are so many models to change that you&#39;d rather just update the collection in bulk. Use <strong><code>reset()</code></strong> to replace a collection with a new list of models (or attribute hashes), triggering a single <code>&quot;reset&quot;</code> event at the end. For convenience, within a <code>&quot;reset&quot;</code> event, the list of any previous models is available as <code>options.previousModels</code>.</p>
<p>Returns the newly-set models.</p>
<p>Calling <code>collection.reset()</code> without passing any models as arguments will empty the entire collection.</p>
<a name="ampersand-collection-sort" class="anchor" href="#ampersand-collection-sort"><h3><span class="header-link"></span>sort <code>collection.sort([options])</code></h3></a><p>Force a collection to re-sort itself. Triggers a <code>&quot;sort&quot;</code> event on the collection.</p>
<p>You don&#39;t need to call this under normal circumstances, as a collection with a <code>comparator</code> will sort itself whenever a model is added. To prevent this when adding a model, pass a <code>{sort: false}</code> option to <code>add()</code>.</p>
<a name="ampersand-collection-models" class="anchor" href="#ampersand-collection-models"><h3><span class="header-link"></span>models <code>collection.models</code></h3></a><p>Raw access to the JavaScript array of models inside of the collection. Usually you&#39;ll want to use <code>get</code>, <code>at</code>, or the <a href="#ampersand-collection-proxied-es5-array-methods-9">proxied array methods</a> to access model objects, but occasionally a direct reference to the array is desired.</p>
<a name="ampersand-collection-comparator" class="anchor" href="#ampersand-collection-comparator"><h3><span class="header-link"></span>comparator</h3></a><p>The <code>comparator</code> option lets you define how models in a collection are sorted. There&#39;s a few ways to declare <code>comparator</code>:</p>
<ul>
<li>Passing <code>false</code> prevents sorting</li>
<li>Passing <code>string</code> sorts the collection by a specific model attribute</li>
<li>Passing <code>function</code> will use native array <code>sort</code> function; which you can define with either 1 argument (each model one by one), or multiple arguments (which lets you write custom compare functions with next 2 models as arguments).</li>
</ul>
<a name="ampersand-collection-proxied-es5-array-methods-9" class="anchor" href="#ampersand-collection-proxied-es5-array-methods-9"><h3><span class="header-link"></span>proxied ES5 array methods (9)</h3></a><p>The base <code>AmpersandCollection</code> proxies some basic ES5 methods to the underlying model array. Further documentation of these methods is available at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods">MDN</a></p>
<ul>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>every</li>
<li>some</li>
<li>forEach</li>
<li>each (alias for forEach)</li>
<li>map</li>
<li>filter</li>
<li>reduce</li>
<li>reduceRight</li>
</ul>
<p>Unlike Backbone collections, it does not include Underscore and all of its array methods. But if you want more functions than those built into modern browsers, you can mixin <a href="https://github.com/AmpersandJS/ampersand-collection-underscore-mixin"><code>ampersand-collection-underscore-mixin</code></a> to get them.</p>
<pre><code class="javascript">var people = People([
    { name: &#39;Phil&#39;, hatColor: &#39;red&#39; },
    { name: &#39;Jenn&#39;, hatColor: &#39;green&#39; },
    { name: &#39;Henrik&#39;, hatColor: &#39;blue&#39; },
    { name: &#39;Julie&#39;, hatColor: &#39;yellow&#39; }
]);

people.map(function (person) { return person.name; }) //=&gt; [&#39;Phil&#39;, &#39;Jenn&#39;, &#39;Henrik&#39;, &#39;Julie&#39;]

people.filter(function (person) {
    return person.name[0] === &#39;J&#39;;
}) //=&gt; [&#39;Jenn&#39;, &#39;Julie&#39;]
</code></pre>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-rest-collection/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-rest-collection" href="#ampersand-rest-collection" class="anchor">
            <h1><span class="header-link"></span>ampersand-rest-collection</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-rest-collection</h4>
            <p class="module-version">latest v5.0.0</p>
            <p class="module-description">ampersand-collection with REST and Lodash mixins.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-rest-collection">github</a><a href="https://www.npmjs.org/package/ampersand-rest-collection">npm</a></p>
          </div>
          <div><p>Extends ampersand-collection with REST and Lodash mixins.</p>
<p>This makes ampersand-collection work and act a lot like Backbone.Collection, if youre planning on hitting a REST-ful API this is probably what you want to use.</p>
<a name="ampersand-rest-collection-install" class="anchor" href="#ampersand-rest-collection-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-rest-collection
</code></pre><a name="ampersand-rest-collection-api-reference" class="anchor" href="#ampersand-rest-collection-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><p>The ampersand-rest-collection is simply an <a href="#ampersand-collection">ampersand-collection</a> extended with two mixins: ampersand-collection-rest-mixin and ampersand-collection-lodash-mixin.</p>
<pre><code class="javascript">var Collection = require(&quot;ampersand-collection&quot;);
var lodashMixin = require(&quot;ampersand-collection-lodash-mixin&quot;);
var restMixins = require(&quot;ampersand-collection-rest-mixin&quot;);

module.exports = Collection.extend(lodashMixin, restMixins);
</code></pre>
<a name="ampersand-rest-collection-ajaxconfig" class="anchor" href="#ampersand-rest-collection-ajaxconfig"><h3><span class="header-link"></span>ajaxConfig <code>AmpersandRestCollection.extend({ ajaxConfig: function () { ... } })</code></h3></a><p>ampersand-sync will call ajaxConfig on your collection before it makes the request to the server, and will merge in any options you return to the request. When extending your own collection, set an ajaxConfig function to modify the request before it goes to the server.</p>
<p>ajaxConfig can either be an object, or a function that returns an object, with the following options:</p>
<ul>
<li><code>useXDR</code> [boolean]: (applies to IE9 only with cross domain requests): signifies that this is a cross-domain request and that IE should use it&#39;s XDomainRequest object. This is required if you&#39;re making cross-domain requests and want to support IE9). Note that XDR doesn&#39;t support headers/withCredentials.</li>
<li><code>headers</code> [object]: any extra headers to send with the request.</li>
<li><code>xhrFields</code> [object]: any fields to set directly on the <a href="https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest">XHR</a> request object, most typically:<ul>
<li><code>withCredentials</code> [boolean]: whether to send cross domain requests with authorization headers/cookies. Useful if you&#39;re making cross sub-domain requests with a root-domain auth cookie.</li>
</ul>
</li>
<li><code>beforeSend</code> [function]: beforeSend will be called before the request is made, and will be passed the raw <code>xhr</code> object if you wish to modify it directly before it&#39;s sent.</li>
</ul>
<pre><code class="javascript">var MyCollection = AmpersandRestCollection.extend({
    url: &#39;http://otherdomain.example.com/stuff&#39;,

    ajaxConfig: function () {
        return {
            headers: {
                &#39;Access-Token&#39;: this.accessToken
            },
            xhrFields: {
                withCredentials: true
            }
        };
    }
});

var collection = new MyCollection()
collection.fetch();
</code></pre>
<a name="ampersand-rest-collection-fetch" class="anchor" href="#ampersand-rest-collection-fetch"><h3><span class="header-link"></span>fetch <code>collection.fetch([options])</code></h3></a><p>Fetch the default set of models for the collection from the server, <a href="#ampersand-collection-set">setting</a> them on the collection when they arrive. If the collection already contains data, by default, the operation of <a href="#ampersand-collection-set">set</a> will add new models from the server, merge the attributes of existing ones, and remove any which aren&#39;t in the response. This behaviour can be modified with the <code>reset</code>, <code>add</code>, <code>remove</code>, <code>merge</code> options.</p>
<p>Options:</p>
<ul>
<li><code>success</code> {Function} [optional] - callback to be called if the request was successful, will be passed <code>(collection, response, options)</code> as arguments.</li>
<li><code>error</code> {Function} [optional] - callback to be called if the request was not successful, will be passed <code>(collection, response, options)</code> as arguments.</li>
<li><code>reset</code> {Boolean} [optional] - call <a href="#ampersand-collection-reset">reset</a> instead of set with the models returned from the server, <em>defaults to false</em>.</li>
<li><code>add</code> {Boolean} [optional] - (assuming <code>reset</code> is false), <code>{add: false}</code> prevents the call to <code>set</code> from adding new models retrieved from the server that aren&#39;t in the local collection. <em>Defaults to false</em></li>
<li><code>remove</code> {Boolean} [optional] - (assuming <code>reset</code> is false), <code>{remove: false}</code> prevents the call to <code>set</code> from removing models that are in the local collection but aren&#39;t returned by the server. <em>Defaults to false</em></li>
<li><code>merge</code> {Boolean} [optional] - (assuming <code>reset</code> is false), <code>{merge: false}</code> prevents the call to <code>set</code> from updating models in the local collection which have changed on the server. <em>Defaults to false</em></li>
</ul>
<p>You can also pass any options that <a href="https://github.com/Raynos/xhr">xhr</a> expects to modify the query. For example: to fetch a specific page of a paginated collection: <code>collection.fetch({ data: { page: 3 } })</code></p>
<a name="ampersand-rest-collection-getorfetch" class="anchor" href="#ampersand-rest-collection-getorfetch"><h3><span class="header-link"></span>getOrFetch <code>collection.getOrFetch(&#39;id&#39;, [options], callback)</code></h3></a><p>Convenience method. Gets a model from the server or from the collection if a model with that id already exists.</p>
<p>By default it will only fetch and add the model with the id you pass in.</p>
<pre><code class="javascript">collection.getOrFetch(&#39;42&#39;, function (err, model) {
    if (err) {
        console.log(&#39;handle&#39;);
    } else {
        // `model` here is a fully inflated model
        // It gets added to the collection automatically.
        // If the collection was empty before, it&#39;s got 1
        // now.
    }
});
</code></pre>
<p>If you pass <code>{all: true}</code> it will fetch the entire collection (by calling its <code>fetch</code> method) and then do a <code>get</code> to attempt to pull out the model by the id you specified.</p>
<pre><code class="javascript">collection.getOrFetch(&#39;42&#39;, {all: true}, function (err, model) {
    if (err) {
        console.log(&#39;handle&#39;);
    } else {
        // `model` here is a fully inflated model
        // It gets added to the collection automatically.
    }
});
</code></pre>
<a name="ampersand-rest-collection-fetchbyid" class="anchor" href="#ampersand-rest-collection-fetchbyid"><h3><span class="header-link"></span>fetchById <code>collection.fetchById(&#39;id&#39;, callback)</code></h3></a><p>Fetches and adds a model by id to the collection. This is what <code>getOrFetch</code> uses if it doesn&#39;t have a model already.</p>
<pre><code class="javascript">collection.fetchById(&#39;42&#39;, function (err, model) {
    // returns inflated, added model with a `null` error
    // or an error object.
});
</code></pre>
<a name="ampersand-rest-collection-create" class="anchor" href="#ampersand-rest-collection-create"><h3><span class="header-link"></span>create <code>collection.create(model, [options])</code></h3></a><p>Convenience to create a new instance of a model within a collection. Equivalent to instantiating a model with a hash of attributes, saving the model to the server, and adding the model to the set after being successfully created. Returns the new model. If client-side validation failed, the model will be unsaved, with validation errors. In order for this to work, you should set the <code>model</code> property of the collection. The create method can accept either an attributes hash or an existing, unsaved model object.</p>
<p>Creating a model will cause an immediate <code>&quot;add&quot;</code> event to be triggered on the collection, a <code>&quot;request&quot;</code> event as the new model is sent to the server, as well as a <code>&quot;sync&quot;</code> event, once the server has responded with the successful creation of the model. Pass <code>{wait: true}</code> if you&#39;d like to wait for the server before adding the new model to the collection.</p>
<pre><code>var Library = AmpersandRestCollection.extend({
  model: Book
});

var library = new Library;

var othello = library.create({
  title: &quot;Othello&quot;,
  author: &quot;William Shakespeare&quot;
});
</code></pre><a name="ampersand-rest-collection-sync" class="anchor" href="#ampersand-rest-collection-sync"><h3><span class="header-link"></span>sync <code>model.sync(method, collection, [options])</code></h3></a><p>Simple delegation to ampersand-sync to persist the collection to the server. Can be overridden for custom behaviour.</p>
<a name="ampersand-rest-collection-lodash-methods-42" class="anchor" href="#ampersand-rest-collection-lodash-methods-42"><h3><span class="header-link"></span>lodash methods (42)</h3></a><p>The ampersand-collection-lodash-mixin proxies the collection methods in lodash onto the underlying models array for the collection. For example:</p>
<pre><code class="javascript">books.each(function(book) {
  book.publish();
});

var titles = books.map(function(book) {
  return book.get(&quot;title&quot;);
});

var publishedBooks = books.filter(function(book) {
  return book.get(&quot;published&quot;) === true;
});

var alphabetical = books.sortBy(function(book) {
  return book.author.get(&quot;name&quot;).toLowerCase();
});
</code></pre>
<p>The full list of proxied methods is:</p>
<ul>
<li><a href="https://lodash.com/docs#countBy">countBy</a></li>
<li><a href="https://lodash.com/docs#difference">difference</a></li>
<li><a href="https://lodash.com/docs#drop">drop</a></li>
<li><a href="https://lodash.com/docs#each">each</a></li>
<li><a href="https://lodash.com/docs#every">every</a></li>
<li><a href="https://lodash.com/docs#filter">filter</a></li>
<li><a href="https://lodash.com/docs#findWhere">findWhere</a></li>
<li><a href="https://lodash.com/docs#find">find</a></li>
<li><a href="https://lodash.com/docs#first">first</a></li>
<li><a href="https://lodash.com/docs#forEach">forEach</a></li>
<li><a href="https://lodash.com/docs#groupBy">groupBy</a></li>
<li><a href="https://lodash.com/docs#includes">includes</a></li>
<li><a href="https://lodash.com/docs#indexBy">indexBy</a></li>
<li><a href="https://lodash.com/docs#indexOf">indexOf</a></li>
<li><a href="https://lodash.com/docs#initial">initial</a></li>
<li><a href="https://lodash.com/docs#invoke">invoke</a></li>
<li><a href="https://lodash.com/docs#isEmpty">isEmpty</a></li>
<li><a href="https://lodash.com/docs#lastIndexOf">lastIndexOf</a></li>
<li><a href="https://lodash.com/docs#last">last</a></li>
<li><a href="https://lodash.com/docs#map">map</a></li>
<li><a href="https://lodash.com/docs#max">max</a></li>
<li><a href="https://lodash.com/docs#min">min</a></li>
<li><a href="https://lodash.com/docs#partition">partition</a></li>
<li><a href="https://lodash.com/docs#pluck">pluck</a></li>
<li><a href="https://lodash.com/docs#reduceRight">reduceRight</a></li>
<li><a href="https://lodash.com/docs#reduce">reduce</a></li>
<li><a href="https://lodash.com/docs#reject">reject</a></li>
<li><a href="https://lodash.com/docs#rest">rest</a></li>
<li><a href="https://lodash.com/docs#sample">sample</a></li>
<li><a href="https://lodash.com/docs#shuffle">shuffle</a></li>
<li><a href="https://lodash.com/docs#size">size</a></li>
<li><a href="https://lodash.com/docs#some">some</a></li>
<li><a href="https://lodash.com/docs#sortBy">sortBy</a></li>
<li><a href="https://lodash.com/docs#take">take</a></li>
<li><a href="https://lodash.com/docs#where">where</a></li>
<li><a href="https://lodash.com/docs#without">without</a></li>
</ul>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-view/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-view" href="#ampersand-view" class="anchor">
            <h1><span class="header-link"></span>ampersand-view</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-view</h4>
            <p class="module-version">latest v9.0.2</p>
            <p class="module-description">A smart base view for Backbone apps, to make it easy to bind collections and properties to the DOM.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-view">github</a><a href="https://www.npmjs.org/package/ampersand-view">npm</a></p>
          </div>
          <div><p>Lead Maintainer: <a href="https://github.com/cdaringe">Christopher Dieringer</a></p>
<p>A set of common helpers and conventions for using as a base view for ampersand.js apps.</p>
<p>What does it do?</p>
<ol>
<li>Gives you a proven pattern for managing/binding the contents of an element.</li>
<li>Simple declarative property/template bindings without needing to include a template engine that does it for you. This keeps your logic out of your templates and lets you use a string of HTML as a fully dynamic template or just a simple function that returns an HTML string.</li>
<li>The view&#39;s base element is replaced (or created) during a render. So, rather than having to specify tag type and attributes in javascript in the view definition you can just include that in your template like everything else.</li>
<li>A way to render a collection of models within an element in the view, each with their own view, preserving order, and doing proper cleanup when the main view is removed.</li>
<li>A simple way to render sub-views that get cleaned up when the parent view is removed.</li>
</ol>
<a name="ampersand-view-install" class="anchor" href="#ampersand-view-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-view
</code></pre><a name="ampersand-view-api-reference" class="anchor" href="#ampersand-view-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><p>Note that this is a fork of Backbone&#39;s view so most of the public methods/properties here still exist: <a href="http://backbonejs.org/#View">http://backbonejs.org/#View</a>.<code>AmpersandView</code> extends <a href="https://github.com/ampersandjs/ampersand-state"><code>AmpersandState</code></a> so it can have it&#39;s own <code>props</code> values for example and can be bound directly to the template without a backing model object.</p>
<a name="ampersand-view-extend" class="anchor" href="#ampersand-view-extend"><h3><span class="header-link"></span>extend <code>AmpersandView.extend([properties])</code></h3></a><p>Get started with views by creating a custom view class. Ampersand views have a sane default render function, which you don&#39;t necessarily have to override, but you probably will wish to specify a <a href="http://ampersandjs.com/docs#ampersand-view-template"><code>template</code></a>, your declarative <a href="http://ampersandjs.com/docs#ampersand-view-events">event handlers</a> and your <a href="http://ampersandjs.com/docs#ampersand-view-bindings">view bindings</a>.</p>
<pre><code class="javascript">var PersonRowView = AmpersandView.extend({
    template: &quot;&lt;li&gt; &lt;span data-hook=&#39;name&#39;&gt;&lt;/span&gt; &lt;span data-hook=&#39;age&#39;&gt;&lt;/span&gt; &lt;a data-hook=&#39;edit&#39;&gt;edit&lt;/a&gt; &lt;/li&gt;&quot;,

    events: {
        &quot;click [data-hook=edit]&quot;: &quot;edit&quot;
    },

    bindings: {
        &quot;model.name&quot;: {
            type: &#39;text&#39;,
            hook: &#39;name&#39;
        },

        &quot;model.age&quot;: {
            type: &#39;text&#39;,
            hook: &#39;age&#39;
        }
    },

    edit: function () {
        //...
    }
});
</code></pre>
<a name="ampersand-view-template" class="anchor" href="#ampersand-view-template"><h3><span class="header-link"></span>template <code>AmpersandView.extend({ template: &quot;&lt;div&gt;&lt;input&gt;&lt;/div&gt;&quot; })</code></h3></a><p>The <code>.template</code> is a property for the view prototype. It should either be a string of HTML or a function that returns a string of HTML or a DOM element. It isn&#39;t required, but it is used as a default for calling <code>renderWithTemplate</code>.</p>
<p>The important thing to note is that <strong><em>the returned string/HTML should not have more than one root element</em></strong>. This is because the view code assumes that it has one and only one root element that becomes the <code>.el</code> property of the instantiated view.</p>
<p>For more information about creating, and compiling templates, <a href="http://ampersandjs.com/learn/templates">read the templating guide</a>.</p>
<a name="ampersand-view-autorender" class="anchor" href="#ampersand-view-autorender"><h3><span class="header-link"></span>autoRender <code>AmpersandView.extend({ autoRender: true })</code></h3></a><p>The <code>.autoRender</code> property lets you optionally specify that the view should just automatically render with all the defaults. This requires that you at minimum specify a <a href="http://ampersandjs.com/docs#ampersand-view-template">template</a> string or function.</p>
<p>By setting <code>autoRender: true</code> the view will simply call <code>.renderWithTemplate</code> for you (after your <code>initialize</code> method if present). So for simple views, if you&#39;ve got a few bindings and a template your whole view could just be really declarative like this:</p>
<pre><code class="javascript">var AmpersandView = require(&#39;ampersand-view&#39;);


module.exports = AmpersandView.extend({
    autoRender: true,
    template: &#39;&lt;div&gt;&lt;span id=&quot;username&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#39;,
    bindings: {
        name: &#39;#username&#39;
    }
});
</code></pre>
<p><strong>Note:</strong> if you are using a template function (and not a string) the template function will get called with a context argument that looks like this, giving you access to <code>.model</code>, <code>.collection</code> and any other props you have defined on the view from the template.</p>
<pre><code class="javascript">this.renderWithTemplate(this, this.template);
</code></pre>
<a name="ampersand-view-events" class="anchor" href="#ampersand-view-events"><h3><span class="header-link"></span>events <code>AmpersandView.extend({ events: { /* ...events hash... */ } })</code></h3></a><p>The events hash allows you to specify declarative callbacks for DOM events within the view. This is much clearer and less complex than calling <code>el.addEventListener(&#39;click&#39;, ...)</code> everywhere.</p>
<ul>
<li>Events are written in the format <code>{&quot;event selector&quot;: &quot;callback&quot;}</code>.</li>
<li>The callback may either be the name of a method on the view, or an actual function.</li>
<li>Omitting the <code>selector</code> causes the event to be bound to the view&#39;s root element (<code>this.el</code>).</li>
<li>The events property may also be defined as a function that returns an <em>events</em> hash, to make it easier to programmatically define your events, as well as inherit them from parent views.</li>
</ul>
<p>Using the events hash has a number of benefits over manually binding events during the <code>render</code> call:</p>
<ul>
<li>All attached callbacks are bound to the view before being handed off to the event handler, so when the callbacks are invoked, <code>this</code> continues to refer to the view object.</li>
<li>All event handlers are delegated to the view&#39;s root el, meaning elements changed when the view is updated don&#39;t need to be unbound and rebound.</li>
<li>All events handlers are cleanly removed when the view is <a href="http://ampersandjs.com/docs#ampersand-view-remove">removed</a>.</li>
</ul>
<pre><code>var DocumentView = AmpersandView.extend({

  events: {
    //bind to a double click on the root element
    &quot;dblclick&quot;                : &quot;open&quot;,

    //bind to a click on an element with both &#39;icon&#39; and &#39;doc&#39; classes
    &quot;click .icon.doc&quot;         : &quot;select&quot;,

    &quot;contextmenu .icon.doc&quot;   : &quot;showMenu&quot;,
    &quot;click .show_notes&quot;       : &quot;toggleNotes&quot;,
    &quot;click .title .lock&quot;      : &quot;editAccessLevel&quot;,
    &quot;mouseover .title .date&quot;  : &quot;showTooltip&quot;
  },

  open: function() {
    window.open(this.model.viewer_url);
  },

  select: function() {
    this.model.selected = true;
  },

  //...

});
</code></pre><p>Note that the <code>events</code> definition is not merged with the superclass definition. If you want to merge
<code>events</code> from a superclass, you have to do it explicitly:</p>
<pre><code>var SuperheroRowView = PersonRowView.extend({
  events: _.extend({}, PersonRowView.prototype.events, {
    &#39;click [data-hook=edit-secret-identitiy]&#39;: &#39;editSecretIdentity&#39;
  })
});
</code></pre><a name="ampersand-view-bindings" class="anchor" href="#ampersand-view-bindings"><h3><span class="header-link"></span>bindings</h3></a><p>The bindings hash gives you a declarative way of specifying which elements in your view should be updated when the view&#39;s model is changed.</p>
<p>For a full reference of available binding types see the <a href="http://ampersandjs.com/docs#ampersand-dom-bindings">ampersand-dom-bindings</a> section.</p>
<p>For example, with a model like this:</p>
<pre><code class="javascript">var Person = AmpersandModel.extend({
    props: {
        name: &#39;string&#39;,
        age: &#39;number&#39;,
        avatarURL: &#39;string&#39;
    },
    session: {
        selected: &#39;boolean&#39;
    }
});
</code></pre>
<p>and a template like this:</p>
<pre><code class="undefinedhtml">&lt;!-- templates.person --&gt;
&lt;li&gt;
  &lt;img data-hook=&quot;avatar&quot;&gt;
  &lt;span data-hook=&quot;name&quot;&gt;&lt;/span&gt;
  age: &lt;span data-hook=&quot;age&quot;&gt;&lt;/span&gt;
&lt;/li&gt;
</code></pre>
<p>you might have a binding hash in your view like this:</p>
<pre><code class="javascript">var PersonView = AmpersandView.extend({
    templates: templates.person,

    bindings: {
        &#39;model.name&#39;: {
            type: &#39;text&#39;,
            hook: &#39;name&#39;
        },

        &#39;model.age&#39;: &#39;[data-hook=age]&#39;, //shorthand of the above

        &#39;model.avatarURL&#39;: {
            type: &#39;attribute&#39;,
            name: &#39;src&#39;,
            hook: &#39;avatar&#39;
        },

        //no selector, selects the root element
        &#39;model.selected&#39;: {
            type: &#39;booleanClass&#39;,
            name: &#39;active&#39; //class to toggle
        }
    }
});
</code></pre>
<p>Note that the <code>bindings</code> definition is not merged with the superclass definition. If you want to merge
<code>bindings</code> from a superclass, you have to do it explicitly:</p>
<pre><code>var SuperheroRowView = PersonRowView.extend({
  bindings: _.extend({}, PersonRowView.prototype.bindings, {
    &#39;model.secretIdentity&#39;: &#39;[data-hook=secret-identity]&#39;
  })
});
</code></pre><a name="ampersand-view-el" class="anchor" href="#ampersand-view-el"><h3><span class="header-link"></span>el <code>view.el</code></h3></a><p>All rendered views have a single DOM node which they manage, which is acessible from the <code>.el</code> property on the view. Allowing you to insert it into the DOM from the parent context.</p>
<pre><code>var view = new PersonView({ model: me });
view.render();

document.querySelector(&#39;#viewContainer&#39;).appendChild(view.el);
</code></pre><a name="ampersand-view-constructor" class="anchor" href="#ampersand-view-constructor"><h3><span class="header-link"></span>constructor <code>new AmpersandView([options])</code></h3></a><p>The default <code>AmpersandView</code> constructor accepts an optional <code>options</code> object, and:</p>
<ul>
<li>Attaches the following options directly to the instantiated view, overriding the defaults: <code>model</code>, <code>collection</code>, <code>el</code>.</li>
<li>Sets up event bindings defined in the <code>events</code> hash.</li>
<li>Sets up the model bindings defined in the <code>bindings</code> hash.</li>
<li>Initializes any subviews defined in the <code>subviews</code> hash.</li>
<li>Calls <code>initialize</code> passing it the options hash.</li>
<li>Renders the view, if <code>autoRender</code> is true and a template is defined.</li>
</ul>
<p>Typical use-cases for the options hash:</p>
<ul>
<li>To initialize a view with an <code>el</code> <em>already</em> in the DOM, pass it as an option: <code>new AmpersandView({ el: existingElement })</code>.</li>
<li>To perform extra work when initializing a new view, override the <code>initialize</code> function in the extend call, rather than modifying the constructor, it&#39;s easier.</li>
</ul>
<a name="ampersand-view-initialize" class="anchor" href="#ampersand-view-initialize"><h3><span class="header-link"></span>initialize <code>new AmpersandView([options])</code></h3></a><p>Called by the default view constructor after the view is initialized. Overwrite initialize in your views to perform some extra work when the view is initialized. Initially it&#39;s a noop:</p>
<pre><code class="javascript">var MyView = AmpersandView.extend({
    initialize: function (options) {
        console.log(&quot;The options are:&quot;, options);
    }
});

var view = new MyView({ foo: &#39;bar&#39; });
//=&gt; logs &#39;The options are: {foo: &quot;bar&quot;}&#39;
</code></pre>
<p>If you want to extend the <code>initialize</code> function of a superclass instead of redefining it completely, you can
explicitly call the <code>initialize</code> of the superclass at the right time:</p>
<pre><code>var SuperheroRowView = PersonRowView.extend({
  initialize: function () {
    PersonRowView.prototype.initialize.apply(this, arguments);
    doSomeOtherStuffHere();
  })
});
</code></pre><a name="ampersand-view-render" class="anchor" href="#ampersand-view-render"><h3><span class="header-link"></span>render <code>view.render()</code></h3></a><p>Render is a part of the <a href="http://ampersandjs.com/learn/view-conventions">Ampersand View conventions</a>. You can override the default view method when extending AmpersandView if you wish, but as part of the conventions, calling render should:</p>
<ul>
<li>Create a <code>this.el</code> property if the view doesn&#39;t already have one, and populate it with your view template</li>
<li>or if the view already has a <code>this.el</code> attribute, render should either populate it with your view template, or create a new element and replace the existing <code>this.el</code> if it&#39;s in the DOM tree.</li>
<li>Not be a problem if it&#39;s called more than once.</li>
</ul>
<p>The default render looks like this:</p>
<pre><code class="javascript">render: function () {
    this.renderWithTemplate(this);
    return this;
}
</code></pre>
<p>If you want to extend the <code>render</code> function of a superclass instead of redefining it completely, you can
explicitly call the <code>render</code> of the superclass at the right time:</p>
<pre><code>var SuperheroRowView = PersonRowView.extend({
  render: function () {
    PersonRowView.prototype.render.apply(this, arguments);
    doSomeOtherStuffHere();
  })
});
</code></pre><p>ampersand-view triggers a <code>&#39;render&#39;</code> event for your convenience, too, if you want to set listeners for it.  The <code>&#39;render&#39;</code> and <code>&#39;remove&#39;</code> events emitted by this module are merely convenience events, as you may listen solely to <code>change:rendered</code> in order to capture the render/remove events in just one listener.</p>
<a name="ampersand-view-rendercollection" class="anchor" href="#ampersand-view-rendercollection"><h3><span class="header-link"></span>renderCollection <code>view.renderCollection(collection, ItemView, containerEl, [viewOptions])</code></h3></a><ul>
<li><code>collection</code> {Backbone Collection} The instantiated collection we wish to render.</li>
<li><code>ItemView</code> {View Constructor | Function} The view constructor that will be instantiated for each model in the collection or a function that will return an instance of a given constructor. <code>options</code> object is passed as a first argument to a function, which can be used to access <code>options.model</code> and determine which view should be instantiated. This view will be used with a reference to the model and collection and the item view&#39;s <code>render</code> method will be called with an object containing a reference to the containerElement as follows: <code>.render({containerEl: &lt;&lt; element &gt;&gt;})</code>.</li>
<li>containerEl {Element | String} This can either be an actual DOM element or a CSS selector string such as <code>.container</code>. If a string is passed ampersand-view runs <code>this.query(&#39;YOUR STRING&#39;)</code> to try to grab the element that should contain the collection of views. If you don&#39;t supply a <code>containerEl</code> it will default to <code>this.el</code>.</li>
<li><code>viewOptions</code> {Object} [optional] Additional options<ul>
<li><code>viewOptions</code> {Object} Options object that will get passed to the <code>initialize</code> method of the individual item views.</li>
<li><code>filter</code> {Function} [optional] Function that will be used to determine if a model should be rendered in this collection view. It will get called with a model and you simply return <code>true</code> or <code>false</code>.</li>
<li><code>reverse</code> {Boolean} [optional] Convenience for reversing order in which the items are rendered.</li>
</ul>
</li>
</ul>
<p>This method will maintain this collection within that container element. Including proper handling of add, remove, sort, reset, etc.</p>
<p>Also, when the parent view gets <code>.remove()</code>&#39;ed any event handlers registered by the individual item views will be properly removed as well.</p>
<p>Each item view will only be <code>.render()</code>&#39;ed once (unless you change that within the item view itself).</p>
<p>The collection view instance will be returned from the function.</p>
<a name="ampersand-view-example" class="anchor" href="#ampersand-view-example"><h4><span class="header-link"></span>Example:</h4></a><pre><code class="javascript">// some views for individual items in the collection
var ItemView = AmpersandView.extend({ ... });
var AlternativeItemView = AmpersandView.extend({ ... });

// the main view
var MainView = AmpersandView.extend({
    template: &#39;&lt;section class=&quot;page&quot;&gt;&lt;ul class=&quot;itemContainer&quot;&gt;&lt;/ul&gt;&lt;/section&gt;&#39;,
    render: function (opts) {
        // render our template as usual
        this.renderWithTemplate(this);

        // call renderCollection with these arguments:
        // 1. collection
        // 2. which view to use for each item in the list
        // 3. which element within this view to use as the container
        // 4. options object (not required):
        //      {
        //          // function used to determine if model should be included
        //          filter: function (model) {},
        //          // boolean to specify reverse rendering order
        //          reverse: false,
        //          // view options object (just gets passed to item view&#39;s `initialize` method)
        //          viewOptions: {}
        //      }
        // returns the collection view instance
        var collectionView = this.renderCollection(this.collection, ItemView, this.el.querySelector(&#39;.itemContainer&#39;), opts);
        return this;
    }
});

// alternative main view
var AlternativeMainView = AmpersandView.extend({
    template: &#39;&lt;section class=&quot;sidebar&quot;&gt;&lt;ul class=&quot;itemContainer&quot;&gt;&lt;/ul&gt;&lt;/section&gt;&#39;,
    render: function (opts) {
        this.renderWithTemplate(this);
        this.renderCollection(this.collection, function (options) {
            if (options.model.isAlternative) {
                return new AlternativeItemView(options);
            }

            return new ItemView(options);
        }, this.el.querySelector(&#39;.itemContainer&#39;), opts);
        return this;
    }
});
</code></pre>
<a name="ampersand-view-renderwithtemplate" class="anchor" href="#ampersand-view-renderwithtemplate"><h3><span class="header-link"></span>renderWithTemplate <code>view.renderWithTemplate([context], [template])</code></h3></a><ul>
<li><code>context</code> {Object | null} [optional] The context that will be passed to the template function, usually it will be passed the view itself, so that <code>.model</code>, <code>.collection</code> etc are available.</li>
<li><code>template</code> {Function | String} [optional] A function that returns HTML or a string of HTML.</li>
</ul>
<p>This is shortcut for the default rendering you&#39;re going to do in most every render method, which is: use the template property of the view to replace <code>this.el</code> of the view and re-register all handlers from the event hash and any other binding as described above.</p>
<pre><code class="javascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;&#39;,
    bindings: {
        &#39;name&#39;: &#39;a&#39;
    },
    events: {
        &#39;click a&#39;: &#39;handleLinkClick&#39;
    },
    render: function () {
        // this does everything
        // 1. renders template
        // 2. registers delegated click handler
        // 3. inserts and binds the &#39;name&#39; property
        //    of the view&#39;s `this.model` to the &lt;a&gt; tag.
        this.renderWithTemplate();
    }
});
</code></pre>
<a name="ampersand-view-query" class="anchor" href="#ampersand-view-query"><h3><span class="header-link"></span>query <code>view.query(&#39;.classname&#39;)</code></h3></a><p>Runs a <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.querySelector"><code>querySelector</code></a> scoped within the view&#39;s current element (<code>view.el</code>), returning the first matching element in the dom-tree.</p>
<p>notes:</p>
<ul>
<li>It will also match agains the root element.</li>
<li>It will return the root element if you pass <code>&#39;&#39;</code> as the selector.</li>
<li>If no match is found it returns <code>undefined</code></li>
</ul>
<pre><code class="javascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;img class=&quot;avatar&quot; src=&quot;&quot;&gt;&lt;/li&gt;&#39;,
    render: function () {
        this.renderWithTemplate(this);

        // cache an element for easy reference by other methods
        this.imgEl = this.query(&quot;.avatar&quot;);

        return this;
    }
});
</code></pre>
<a name="ampersand-view-querybyhook" class="anchor" href="#ampersand-view-querybyhook"><h3><span class="header-link"></span>queryByHook <code>view.queryByHook(&#39;hookname&#39;)</code></h3></a><p>A convenience method for retrieving an element from the current view by it&#39;s <code>data-hook</code> attribute. Using this approach is a nice way to separate javascript view hooks/bindings from class/id selectors that are being used by CSS.</p>
<p>notes:</p>
<ul>
<li>It also works if you&#39;re using multiple space-separated hooks. So something like <code>&lt;img data-hook=&quot;avatar user-image&quot;/&gt;</code> would still match for <code>queryByHook(&#39;avatar&#39;)</code>.</li>
<li>It simply uses <code>.query()</code> under the hood. So <code>.queryByHook(&#39;avatar&#39;)</code> is equivalent to <code>.query(&#39;[data-hook~=avatar]&#39;)</code></li>
<li>It will also match to root elements.</li>
<li>If no match is found it returns <code>undefined</code>.</li>
</ul>
<pre><code class="javascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;img class=&#39;avatar-rounded&#39; data-hook=&quot;avatar&quot; src=&quot;&quot;&gt;&lt;/li&gt;&#39;,
    render: function () {
        this.renderWithTemplate(this);

        // cache an element for easy reference by other methods
        this.imgEl = this.queryByHook(&#39;avatar&#39;);

        return this;
    }
});
</code></pre>
<a name="ampersand-view-queryall" class="anchor" href="#ampersand-view-queryall"><h3><span class="header-link"></span>queryAll <code>view.queryAll(&#39;.classname&#39;)</code></h3></a><p>Runs a <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.querySelectorAll"><code>querySelectorAll</code></a> scoped within the view&#39;s current element (<code>view.el</code>), returning an array of all matching elements in the dom-tree.</p>
<p>notes:</p>
<ul>
<li>It will also include the root element if it matches the selector.</li>
<li>It returns a real <code>Array</code> not a DOM collection.</li>
</ul>
<a name="ampersand-view-queryallbyhook" class="anchor" href="#ampersand-view-queryallbyhook"><h3><span class="header-link"></span>queryAllByHook <code>view.queryAllByHook(&#39;hookname&#39;)</code></h3></a><p>Uses <code>queryAll</code> method with a given <code>data-hook</code> attribute to retrieve all matching elements scoped within the view&#39;s current element (<code>view.el</code>), returning an array of all matching elements in the dom-tree or an empty array if no results has been found.</p>
<a name="ampersand-view-cacheelements" class="anchor" href="#ampersand-view-cacheelements"><h3><span class="header-link"></span>cacheElements <code>view.cacheElements(hash)</code></h3></a><p>A shortcut for adding reference to specific elements within your view for access later. This is avoids excessive DOM queries and makes it easier to update your view if your template changes.  It returns <code>this</code>.</p>
<p>In your <code>render</code> method. Use it like so:</p>
<pre><code class="javascript">render: function () {
  this.renderWithTemplate(this);

  this.cacheElements({
    pages: &#39;#pages&#39;,
    chat: &#39;#teamChat&#39;,
    nav: &#39;nav#views ul&#39;,
    me: &#39;#me&#39;,
    cheatSheet: &#39;#cheatSheet&#39;,
    omniBox: &#39;[data-hook=omnibox]&#39;
  });

  return this;
}
</code></pre>
<p>Then later you can access elements by reference like so: <code>this.pages</code>, or <code>this.chat</code>.</p>
<a name="ampersand-view-listentoandrun" class="anchor" href="#ampersand-view-listentoandrun"><h3><span class="header-link"></span>listenToAndRun <code>view.listenToAndRun(object, eventsString, callback)</code></h3></a><p>Shortcut for registering a listener for a model and also triggering it right away.</p>
<a name="ampersand-view-remove" class="anchor" href="#ampersand-view-remove"><h3><span class="header-link"></span>remove <code>view.remove()</code></h3></a><p>Removes a view from the DOM, and calls <code>stopListening</code> to remove any bound events that the view has <code>listenTo</code>&#39;d.  This method also triggers a <code>remove</code> event on the view, allowing for listeners (or the view itself) to listen to it and do some action, like cleanup some other resources being used.  The view will trigger the <code>remove</code> event if <code>remove()</code> is overridden.</p>
<pre><code class="javascript">initialize : function() {
  this.listenTo(this,&#39;remove&#39;,this.cleanup);
  // OR this, either statements will call &#39;cleanup&#39; when `remove` is called
  this.once(&#39;remove&#39;,this.cleanup, this);
},

cleanup : function(){
  // do cleanup
}
</code></pre>
<a name="ampersand-view-registersubview" class="anchor" href="#ampersand-view-registersubview"><h3><span class="header-link"></span>registerSubview <code>view.registerSubview(viewInstance)</code></h3></a><ul>
<li>viewInstance {Object} Any object with a &quot;remove&quot; method, typically an instantiated view. But doesn&#39;t have to be, it can be anything with a remove method. The remove method doesn&#39;t have to actually remove itself from the DOM (since the parent view is being removed anyway), it is generally just used for unregistering any handler that it set up.</li>
</ul>
<a name="ampersand-view-rendersubview" class="anchor" href="#ampersand-view-rendersubview"><h3><span class="header-link"></span>renderSubview <code>view.renderSubview(viewInstance, containerEl)</code></h3></a><ul>
<li>viewInstance {Object} Any object with a <code>.remove()</code>, <code>.render()</code> and an <code>.el</code> property that is the DOM element for that view. Typically this is just an instantiated view.</li>
<li>containerEl {Element | String} This can either be an actual DOM element or a CSS selector string such as <code>.container</code>. If a string is passed ampersand-view runs <code>this.query(&#39;YOUR STRING&#39;)</code> to try to grab the element that should contain the sub view. If you don&#39;t supply a <code>containerEl</code> it will default to <code>this.el</code>.</li>
</ul>
<p>This method is just sugar for the common use case of instantiating a view and putting in an element within the parent.</p>
<p>It will:</p>
<ol>
<li>fetch your container (if you gave it a selector string)</li>
<li>register your subview so it gets cleaned up if parent is removed and so <code>view.parent</code> will be available when your subview&#39;s <code>render</code> method gets called</li>
<li>call the subview&#39;s <code>render()</code> method</li>
<li>append it to the container</li>
<li>return the subview</li>
</ol>
<pre><code class="javascript">var view = AmpersandView.extend({
    template: &#39;&lt;li&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/li&gt;&#39;,
    render: function () {
        this.renderWithTemplate();

        //...

        var model = this.model;
        this.renderSubview(new SubView({
            model: model
        }), &#39;.container&#39;);

        //...

    }
});
</code></pre>
<a name="ampersand-view-subviews" class="anchor" href="#ampersand-view-subviews"><h3><span class="header-link"></span>subviews <code>view.subviews</code></h3></a><p>You can declare subviews that you want to render within a view, much like you would bindings. Useful for cases where the data you need for a subview may not be available on first render. Also, simplifies cases where you have lots of subviews.</p>
<p>When the parent view is removed the <code>remove</code> method of all subviews will be called as well.</p>
<p>You declare them as follows:</p>
<pre><code class="javascript">var AmpersandView = require(&#39;ampersand-view&#39;);
var CollectionRenderer = require(&#39;ampersand-collection-view&#39;);
var ViewSwitcher = require(&#39;ampersand-view-switcher&#39;);


module.exports = AmpersandView.extend({
    template: &#39;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;ul data-hook=&quot;collection-container&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&#39;,
    subviews: {
        myStuff: {
            selector: &#39;[data-hook=collection-container]&#39;,
            waitFor: &#39;model.stuffCollection&#39;,
            prepareView: function (el) {
                return new CollectionRenderer({
                    el: el,
                    collection: this.model.stuffCollection
                });
            }
        },
        tab: {
            hook: &#39;switcher&#39;,
            constructor: ViewSwitcher
        }
    }
});
</code></pre>
<p>subview declarations consist of:</p>
<ul>
<li>selector {String} Selector that describes the element within the view that should hold the subview.</li>
<li>hook {String} Alternate method for specifying a container element using its <code>data-hook</code> attribute. Equivalent to <code>selector: &#39;[data-hook=some-hook]&#39;</code>.</li>
<li>constructor {ViewConstructor} Any <a href="http://ampersandjs.com/learn/view-conventions">view conventions compliant</a> view constructor. It will be initialized with <code>{el: [Element grabbed from selector], parent: [reference to parent view instance]}</code>. So if you don&#39;t need to do any custom setup, you can just provide the constructor.</li>
<li>waitFor {String} String specifying they &quot;key-path&quot; (i.e. &#39;model.property&#39;) of the view that must be &quot;truthy&quot; before it should consider the subview ready.</li>
<li>prepareView {Function} Function that will be called once any <code>waitFor</code> condition is met. It will be called with the <code>this</code> context of the parent view and with the element that matches the selector as the argument. It should return an instantiated view instance.</li>
</ul>
<a name="ampersand-view-delegateevents" class="anchor" href="#ampersand-view-delegateevents"><h3><span class="header-link"></span>delegateEvents <code>view.delegateEvents([events])</code></h3></a><p>Creates delegated DOM event handlers for view elements on <code>this.el</code>. If <code>events</code> is omitted, will use the <code>events</code> property on the view.</p>
<p>Generally you won&#39;t need to call <code>delegateEvents</code> yourself, if you define an <code>event</code> hash when extending AmpersandView, <code>delegateEvents</code> will be called for you when the view is initialize.</p>
<p>Events is a hash of  <code>{&quot;event selector&quot;: &quot;callback&quot;}*</code></p>
<p>Will unbind existing events by calling <code>undelegateEvents</code> before binding new ones when called. Allowing you to switch events for different view contexts, or different views bound to the same element.</p>
<pre><code class="javascript">{
  &#39;mousedown .title&#39;:  &#39;edit&#39;,
  &#39;click .button&#39;:     &#39;save&#39;,
  &#39;click .open&#39;:       function (e) { ... }
}
</code></pre>
<a name="ampersand-view-undelegateevents" class="anchor" href="#ampersand-view-undelegateevents"><h3><span class="header-link"></span>undelegateEvents <code>view.undelegateEvents()</code></h3></a><p>Clears all callbacks previously bound to the view with <code>delegateEvents</code>.
You usually don&#39;t need to use this, but may wish to if you have multiple views attached to the same DOM element.</p>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-view-switcher/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-view-switcher" href="#ampersand-view-switcher" class="anchor">
            <h1><span class="header-link"></span>ampersand-view-switcher</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-view-switcher</h4>
            <p class="module-version">latest v2.1.0</p>
            <p class="module-description">A utility for swapping out views inside a container element.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-view-switcher">github</a><a href="https://www.npmjs.org/package/ampersand-view-switcher">npm</a></p>
          </div>
          <div><p>Lead Maintainer: <a href="https://github.com/kamilogorek">Kamil Ogrek</a></p>
<a name="ampersand-view-switcher-purpose" class="anchor" href="#ampersand-view-switcher-purpose"><h2><span class="header-link"></span>Purpose</h2></a><p>This module does one thing: <em>it helps you swap out views inside of an element</em>. It&#39;s compatible with ampersand-view, backbone views and any view that has an <code>.el</code>, <code>.render()</code> and <code>.remove()</code></p>
<p>What might you do with it?</p>
<ul>
<li>build a page container for your app.</li>
<li>build a system for managing display of modals in your single page app.</li>
<li>animate a transition between showing any two views.</li>
</ul>
<p>What it does</p>
<ul>
<li>Takes an instantiated view and renders it in the container.</li>
<li>Removes the existing view from the container and calls <code>remove</code> on it.</li>
<li>Makes it easy to do custom stuff as views are added and removed.</li>
<li>Works either synchronously or asynchronously depending on whether you want to animate transitions between the views.</li>
<li>Makes no assumptions about what your views do or how they&#39;re structured except the following:<ul>
<li>Views should have an <code>.el</code> property that is the root element of the view.</li>
<li>Views should have a <code>.remove()</code> method that cleans up and unbinds methods accordingly.</li>
<li>If your view has a <code>.render()</code> method it will get called before it&#39;s shown.</li>
<li>Beyond this, they could be any object.</li>
</ul>
</li>
<li>IT DOES VERY LITTLE ELSE (and <em>that</em> is a feature)</li>
</ul>
<a name="ampersand-view-switcher-install" class="anchor" href="#ampersand-view-switcher-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-view-switcher
</code></pre><a name="ampersand-view-switcher-example" class="anchor" href="#ampersand-view-switcher-example"><h2><span class="header-link"></span>Example</h2></a><p>Here&#39;s an example of how you might use the view switcher to handle page views within your ampersand app.</p>
<p><code>mainview.js</code></p>
<pre><code class="javascript">var AmpersandView = require(&#39;ampersand-view&#39;);
var ViewSwitcher = require(&#39;ampersand-view-switcher&#39;);
var templates = require(&#39;./templates&#39;);

module.exports = AmpersandView.extend({
    template: templates.body,
    render: function () {
        // render our template
        this.renderWithTemplate();

        // grab the element without our template based on its &quot;data-hook&quot; attribute
        this.pageContainer = this.queryByHook(&#39;page-container&#39;);

        // set up our page switcher for that element
        this.pageSwitcher = new ViewSwitcher(this.pageContainer, {
            // here we provide a few things we&#39;d like to do each time
            // we switch pages in the app.
            show: function (view) {
                // set our document title
                document.title = view.pageTitle || &#39;my awesome app&#39;;
                // scroll to the top
                document.body.scrollTop = 0;
                // perhaps store a reference to our current page on our
                // app global for easy access from the browser console.
                app.currentPage = view;
            }
        });
    }
});
</code></pre>
<p>Or if you wanted to animate them you can do it asynchronously like so:</p>
<pre><code class="javascript">// set up our page switcher for that element
this.pageSwitcher = new ViewSwitcher(this.pageContainer, {
    // whether or not to wait for remove to be done before starting show
    waitForRemove: true,
    // here we provide a few things to do before the element gets
    // removed from the DOM.
    hide: function (oldView, cb) {
        // it&#39;s inserted and rendered for me so we&#39;ll add a class
        // that has a corresponding CSS transition.
        oldView.el.classList.add(&#39;animateOut&#39;);
        // give it time to finish (yes there are other ways to do this)
        setTimeout(cb, 1000);
    },
    // here we provide a few things we&#39;d like to do each time
    // we switch pages in the app.
    show: function (newView) {
        // it&#39;s inserted and rendered for me
        document.title = newView.pageTitle || &#39;app name&#39;;
        document.body.scrollTop = 0;

        // store an additional reference, just because
        app.currentPage = newView;

        newView.el.classList.add(&#39;animateIn&#39;);
    }
});
</code></pre>
<a name="ampersand-view-switcher-api-reference" class="anchor" href="#ampersand-view-switcher-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-view-switcher-constructor" class="anchor" href="#ampersand-view-switcher-constructor"><h3><span class="header-link"></span>constructor <code>new ViewSwitcher(element, [options])</code></h3></a><ul>
<li><code>element</code> {Element} The DOM element that should contain the views.</li>
<li><code>options</code> {Object} [optinal]<ul>
<li><code>show</code> {Function} [optional] A function that gets called when a view is being shown. It&#39;s passed the new view.</li>
<li><code>hide</code> {Function} [optional] A function that gets called when a view is being removed. It&#39;s passed the old view and a callback. If you name 2 incoming arguments for example <code>function (oldView, callback) { ... }</code> the view switcher will wait for you to call the callback before it&#39;s considered ready. If you only use one like this: <code>function (oldView) { ... }</code> it won&#39;t wait for you to call a callback.</li>
<li><code>waitForRemove</code> {Boolean} [default: <code>false</code>] Whether or not to wait until your <code>hide</code> animation callback gets called before starting your <code>show</code> animation.</li>
<li><code>prepend</code> {Boolean} [default: <code>false</code>] Whether or not to prepend the view to the <code>element</code>. When this is <code>false</code>, the view is appended.</li>
<li><code>empty</code> {Function} [optional] A function that gets called any time the view switcher is empty. Including when you instantiate it without giving it a view to start with.</li>
<li><code>view</code> {View} [optional] A view instance to start with.</li>
</ul>
</li>
</ul>
<pre><code class="javascript">var switcher = new ViewSwitcher(document.querySelector(&#39;#pageContainer&#39;));

var view = new MyView({ model: model });

switcher.set(view);
</code></pre>
<a name="ampersand-view-switcher-set" class="anchor" href="#ampersand-view-switcher-set"><h3><span class="header-link"></span>set <code>switcher.set(viewInstance)</code></h3></a><ul>
<li><code>viewInstance</code> {View} The new view to render.</li>
</ul>
<p>The instantiated view switcher has this one main method. Simply call it with the new view you wish to show.</p>
<p>This is most likely going to be an instantiated <a href="https://github.com/ampersandjs/ampersand-view">ampersand-view</a> or Backbone.View, but can be anything that has a <code>.el</code> property that represents that view&#39;s root element and <code>.remove()</code> method that cleans up after itself. In addition if your custom view object has a <code>.render()</code> method it will get called before the view is added to the DOM.</p>
<pre><code class="javascript">var switcher = new ViewSwitcher(document.querySelector(&#39;#pageContainer&#39;));

var view = new MyView({ model: model });

switcher.set(view);
</code></pre>
<a name="ampersand-view-switcher-clear" class="anchor" href="#ampersand-view-switcher-clear"><h3><span class="header-link"></span>clear <code>switcher.clear(callback)</code></h3></a><ul>
<li><code>callback</code> {Function} [optional] An optional callback when removed. Useful if you&#39;re doing custom animations.</li>
</ul>
<p>Removes the current view from the view switcher. Calls <code>callback</code> when done if one was provided.`</p>
<pre><code class="javascript">var switcher = new ViewSwitcher(document.querySelector(&#39;#pageContainer&#39;));

var view = new MyView({ model: model });

switcher.set(view);

switcher.clear();
</code></pre>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-router/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-router" href="#ampersand-router" class="anchor">
            <h1><span class="header-link"></span>ampersand-router</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-router</h4>
            <p class="module-version">latest v3.0.2</p>
            <p class="module-description">Clientside router with fallbacks for browsers that don't support pushState. Mostly lifted from Backbone.js.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-router">github</a><a href="https://www.npmjs.org/package/ampersand-router">npm</a></p>
          </div>
          <div><p>Clientside router with fallbacks for browsers that don&#39;t support pushState. Mostly lifted from <a href="http://backbonejs.org/#Router">Backbone.js</a>.</p>
<p>Ampersand-router also adds a <code>redirectTo</code> method which is handy for doing &quot;internal&quot; redirects without breaking backbutton functionality in the browser.</p>
<a name="ampersand-router-install" class="anchor" href="#ampersand-router-install"><h2><span class="header-link"></span>install</h2></a><pre><code>npm install ampersand-router
</code></pre><a name="ampersand-router-api-reference" class="anchor" href="#ampersand-router-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-router-extend" class="anchor" href="#ampersand-router-extend"><h3><span class="header-link"></span>extend <code>AmpersandRouter.extend(properties)</code></h3></a><p>Get started by creating a custom router class. Define actions that are triggered when certain URL fragments are matched, and provide a <a href="#ampersand-router-routes">routes</a> hash that pairs routes to actions. Note that you&#39;ll want to avoid using a leading slash in your route definitions:</p>
<pre><code class="javascript">var AppRouter = AmpersandRouter.extend({

  routes: {
    &quot;help&quot;:                 &quot;help&quot;,    // #help
    &quot;search/:query&quot;:        &quot;search&quot;,  // #search/kiwis
    &quot;search/:query/p:page&quot;: &quot;search&quot;   // #search/kiwis/p7
  },

  help: function() {
    //...
  },

  search: function(query, page) {
    //...
  }

});
</code></pre>
<a name="ampersand-router-routes" class="anchor" href="#ampersand-router-routes"><h3><span class="header-link"></span>routes <code>router.routes</code></h3></a><p>The routes hash maps URLs with parameters to functions on your router (or just direct function definitions, if you prefer), similar to the <a href="#ampersand-view">View</a>&#39;s <a href="#ampersand-view-events">events hash</a>. Routes can contain parameter parts, <code>:param</code>, which match a single URL component between slashes; and splat parts <code>*splat</code>, which can match any number of URL components. Part of a route can be made optional by surrounding it in parentheses <code>(/:optional)</code>.</p>
<p>For example, a route of <code>&quot;search/:query/p:page&quot;</code> will match a fragment of <code>#search/obama/p2</code>, passing <code>&quot;obama&quot;</code> and <code>&quot;2&quot;</code> to the action.</p>
<p>A route of <code>&quot;file/*path&quot;</code> will match <code>#file/nested/folder/file.txt</code>, passing <code>&quot;nested/folder/file.txt&quot;</code> to the action.</p>
<p>A route of <code>&quot;docs/:section(/:subsection)&quot;</code> will match #docs/faq and #docs/faq/installing, passing <code>&quot;faq&quot;</code> to the action in the first case, and passing <code>&quot;faq&quot;</code> and <code>&quot;installing&quot;</code> to the action in the second.</p>
<p>Trailing slashes are treated as part of the URL, and (correctly) treated as a unique route when accessed. <code>docs</code> and <code>docs/</code> will fire different callbacks. If you can&#39;t avoid generating both types of URLs, you can define a <code>&quot;docs(/)&quot;</code> matcher to capture both cases.</p>
<p>When the visitor presses the back button, or enters a URL, and a particular route is matched, the name of the action will be fired as an event, so that other objects can listen to the router, and be notified. In the following example, visiting <code>#help/uploading</code> will fire a <code>route:help</code> event from the router.</p>
<pre><code class="javascript">routes: {
  &quot;help/:page&quot;:         &quot;help&quot;,
  &quot;download/*path&quot;:     &quot;download&quot;,
  &quot;folder/:name&quot;:       &quot;openFolder&quot;,
  &quot;folder/:name-:mode&quot;: &quot;openFolder&quot;
}

router.on(&quot;route:help&quot;, function(page) {
  ...
});
</code></pre>
<a name="ampersand-router-constructor-initialize" class="anchor" href="#ampersand-router-constructor-initialize"><h3><span class="header-link"></span>constructor / initialize <code>new Router([options])</code></h3></a><p>When creating a new router, you may pass its routes hash directly as the <code>routes</code> option, if you choose. All options will also be passed to your <code>initialize</code> function, if defined.</p>
<a name="ampersand-router-route" class="anchor" href="#ampersand-router-route"><h3><span class="header-link"></span>route <code>router.route(route, name, [callback])</code></h3></a><p>Manually create a route for the router, The <code>route</code> argument may be a routing string or regular expression. Each matching capture from the route or regular expression will be passed as an argument to the callback. The <code>name</code> argument will be triggered as a <code>&quot;route:name&quot;</code> event whenever the route is matched. If the <code>callback</code> argument is omitted <code>router[name]</code> will be used instead. Routes added later may override previously declared routes.</p>
<pre><code class="javascript">initialize: function(options) {

  // Matches #page/10, passing &quot;10&quot;
  this.route(&quot;page/:number&quot;, &quot;page&quot;, function(number){ ... });

  // Matches /117-a/b/c/open, passing &quot;117-a/b/c&quot; to this.open
  this.route(/^(.*?)\/open$/, &quot;open&quot;);

},

open: function(id) { ... }
</code></pre>
<a name="ampersand-router-navigate" class="anchor" href="#ampersand-router-navigate"><h3><span class="header-link"></span>navigate <code>router.navigate(fragment, [options])</code></h3></a><p>Whenever you reach a point in your application that you&#39;d like to save as a URL, call <em>navigate</em> in order to update the URL. Route function will be called by default, but if you want to prevent it, you can set the <code>trigger</code> option to <code>false</code>. To update the URL without creating an entry in the browser&#39;s history, set the <code>replace</code> option to <code>true</code>.</p>
<pre><code class="javascript">openPage: function(pageNumber) {
  this.document.pages.at(pageNumber).open();
  this.navigate(&quot;page/&quot; + pageNumber);
}

// Or ...

app.navigate(&quot;help/troubleshooting&quot;, {trigger: false});

// Or ...

app.navigate(&quot;help/troubleshooting&quot;, {replace: true});
</code></pre>
<a name="ampersand-router-reload" class="anchor" href="#ampersand-router-reload"><h3><span class="header-link"></span>reload <code>router.reload()</code></h3></a><p>Allows you to re-navigate to the same page.  Re-runs the route handler
for the current url.</p>
<a name="ampersand-router-redirectto" class="anchor" href="#ampersand-router-redirectto"><h3><span class="header-link"></span>redirectTo <code>router.redirectTo(fragment)</code></h3></a><p>Sometimes you want to be able to redirect to a different route in your application without adding an entry in the browser&#39;s history. RedirectTo is just a shorthand for calling <a href="#ampersand-router-navigate">navigate</a> with both <code>trigger</code> and <code>replace</code> set to <code>true</code>.</p>
<pre><code class="javascript">var AppRouter = AmpersandRouter.extend({
    routes: {
        &#39;login&#39;: &#39;login&#39;,
        &#39;dashboard&#39;: &#39;dashboard&#39;
    },

    dashboard: function () {
        if (!app.me.loggedIn) return this.redirectTo(&#39;login&#39;);

        // show dashboard page...
    }
});
</code></pre>
<a name="ampersand-router-execute" class="anchor" href="#ampersand-router-execute"><h3><span class="header-link"></span>execute <code>router.execute(callback, args)</code></h3></a><p>This method is called internally within the router, whenever a route matches and its corresponding callback is about to be executed. Override it to perform custom parsing or wrapping of your routes, for example, to parse query strings before handing them to your route callback, like so:</p>
<pre><code class="javascript">var Router = AmpersandRouter.extend({
  execute: function(callback, args) {
    args.push(parseQueryString(args.pop()));
    if (callback) callback.apply(this, args);
  }
});
</code></pre>
<a name="ampersand-router-historystart" class="anchor" href="#ampersand-router-historystart"><h3><span class="header-link"></span>history.start <code>router.history.start([options])</code></h3></a><p>AmpersandRouter automatically requires and instantiates a single ampersand-history object. AmpersandHistory serves as a global router (per frame) to handle hashchange events or pushState, match the appropriate route, and trigger callbacks. You shouldn&#39;t ever have to create one of these yourself since ampersand-router already contains one.</p>
<p>When all of your Routers have been created, and all of the routes are set up properly, call <code>router.history.start()</code> on one of your routers to begin monitoring hashchange events, and dispatching routes. Subsequent calls to <code>history.start()</code> will throw an error, and <code>router.history.started()</code> is a boolean value indicating whether it has already been called.</p>
<p>Supported options:</p>
<ul>
<li><strong>pushState</strong> {Boolean} - HTML5 pushState is turned on by default. However if you want to indicate that you don&#39;t want to use it in your application, you can add <code>{pushState: false}</code> to the options. <strong>Defaults to true</strong></li>
<li><strong>hashChange</strong> {Boolean} - If you&#39;d like to use pushState, but have browsers that don&#39;t support it natively use full page refreshes instead, you can add <code>{hashChange: false}</code> to the options. <strong>Defaults to true</strong></li>
<li><strong>root</strong> {String} - If your application is not being served from the root url <code>/</code> of your domain, be sure to tell History where the root really is, as an option: <code>router.history.start({root: &quot;/public/search/&quot;})</code>. <strong>Defaults to <code>/</code></strong></li>
<li><strong>silent</strong> {Boolean} - If the server has already rendered the entire page, and you don&#39;t want the initial route to trigger when starting History, pass <code>silent: true</code>. <strong>Defaults to false</strong></li>
</ul>
<p>When called, if a route succeeds with a match for the current URL, <code>router.history.start()</code> returns <code>true</code>. If no defined route matches the current URL, it returns <code>false</code>.</p>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-events/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-events" href="#ampersand-events" class="anchor">
            <h1><span class="header-link"></span>ampersand-events</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-events</h4>
            <p class="module-version">latest v1.1.1</p>
            <p class="module-description">Module that can be mixed into any object to provide eventing. Heavily based on Backbone Events.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-events">github</a><a href="https://www.npmjs.org/package/ampersand-events">npm</a></p>
          </div>
          <div><p>A module that can be mixed into any object to make it able to trigger events and be listened to. This is heavily based on Backbone Events with a few modifications.</p>
<a name="ampersand-events-install" class="anchor" href="#ampersand-events-install"><h2><span class="header-link"></span>Install</h2></a><pre><code>npm install ampersand-events
</code></pre><a name="ampersand-events-example-usage" class="anchor" href="#ampersand-events-example-usage"><h2><span class="header-link"></span>Example usage</h2></a><p><code>ampersand-events</code> is simply an object of methods. So you can easily add those to any object using any of the following techniques.</p>
<a name="ampersand-events-adding-events-to-a-constructor-or-quotclassquot" class="anchor" href="#ampersand-events-adding-events-to-a-constructor-or-quotclassquot"><h3><span class="header-link"></span>Adding events to a constructor or &quot;class&quot;</h3></a><pre><code class="javascript">var Events = require(&#39;ampersand-events&#39;);
var assign = require(&#39;lodash.assign&#39;);

// Create some constructor
var MyConstructor = function () {};

// Extend the prototype with the event methods and your own:
assign(MyConstructor.prototype, Events, {
    myOtherMethods: function () {}
});

// Now we can trigger and listen for events on
// any instances created with our constructor.
var myObj = new MyConstructor();
</code></pre>
<a name="ampersand-events-using-with-plain-objects" class="anchor" href="#ampersand-events-using-with-plain-objects"><h3><span class="header-link"></span>Using with plain objects</h3></a><pre><code class="javascript">var Events = require(&#39;ampersand-events&#39;);

// Events has an `createEmitter` helper that you can pass
// any object to to add event methods to.
var myObj = {};
Events.createEmitter(myObj);

// it now has event methods
myObject.trigger(&#39;some event&#39;);
</code></pre>
<a name="ampersand-events-using-as-an-event-bus-or-pubsub-channel" class="anchor" href="#ampersand-events-using-as-an-event-bus-or-pubsub-channel"><h3><span class="header-link"></span>Using as an event bus / or pubsub channel</h3></a><p>You can call <code>Event.createEmitter()</code> without any arguments to create an &quot;empty&quot; event emitter.</p>
<p>This can be really useful for creating what you might call an &quot;event bus&quot; or &quot;pubsub&quot; mechanism for things like application events, or whatnot.</p>
<p>Say you created a module like this:</p>
<pre><code>var Events = require(&#39;ampersand-events&#39;);

module.exports = Events.createEmitter();
</code></pre><p>Any module in your app could now require this module and trigger events that other modules in your app could listen for.</p>
<a name="ampersand-events-api-reference" class="anchor" href="#ampersand-events-api-reference"><h2><span class="header-link"></span>API Reference</h2></a><a name="ampersand-events-createemitter" class="anchor" href="#ampersand-events-createemitter"><h3><span class="header-link"></span>createEmitter <code>Events.createEmitter([object])</code></h3></a><p>Modifies any passed object to add event capabilities to it. If you don&#39;t pass any object, it simply creates and returns a new object with event capabilities.</p>
<ul>
<li><code>object</code> {Object} [Optional] Any object you want to add event capabilities to.</li>
</ul>
<p>It simply adds the event methods to the passed in object.</p>
<pre><code class="javascript">var myObj = {};
Events.createEmitter(myObj);

myObj.on(&#39;customEvent&#39;, function () {
    // handle event
});
myObj.trigger(&#39;customEvent&#39;);
</code></pre>
<a name="ampersand-events-on" class="anchor" href="#ampersand-events-on"><h3><span class="header-link"></span>on <code>eventObj.on(eventName, callback, [context])</code></h3></a><p>(aliased as <code>bind</code> for backwards compatibility)</p>
<p>Bind a function to be called each time the <code>eventName</code> is triggered on that object.</p>
<ul>
<li><code>eventName</code> {String} The name of the event to listen for. Can also be <code>&quot;all&quot;</code> which will call your callback no matter what event is triggered.</li>
<li><code>callback</code> {Function} The function to call when the event is triggered.</li>
<li><code>context</code> {Object}[optional] If you provide an object here it will be the value of <code>this</code> inside your callback function.</li>
</ul>
<pre><code class="javascript">myObj.on(&#39;anything&#39;, function () {
    console.log(&#39;I can handle anything!&#39;);
});
</code></pre>
<a name="ampersand-events-once" class="anchor" href="#ampersand-events-once"><h3><span class="header-link"></span>once <code>eventObj.once(eventName, callback, [context])</code></h3></a><p>Exactly like <code>on</code> but removes itself after getting called once no matter how many times the event is triggered.</p>
<a name="ampersand-events-off" class="anchor" href="#ampersand-events-off"><h3><span class="header-link"></span>off <code>eventObj.off([eventName], [callback], [context])</code></h3></a><p>(aliased as <code>unbind</code> for backwards compatibility)</p>
<p>Remove previously bound callback(s) from the object. If no context is specified all versions of callback no matter what context was given will be removed. If no callback was specified, all callbacks for that given <code>eventName</code> will be removed. If no <code>eventName</code> was specified callbacks for all events are removed.</p>
<ul>
<li><code>eventName</code> {String} The name of the event to remove. Pass <code>null</code> to &quot;leave blank&quot;. </li>
<li><code>callback</code> {Function} The function to remove or pass <code>null</code> to &quot;leave blank&quot;.</li>
<li><code>context</code> {Object} Remove all callbacks with this context.</li>
</ul>
<p>These can be used in any combination as shown below:</p>
<pre><code class="javascript">// Removes the `onChange` callback
eventObj.off(&#39;change&#39;, onChange);

// Removes all callbacks listening for &#39;change&#39; events
eventObj.off(&#39;change&#39;);

// Removes the `onChange` callback for any event
eventObj.off(null, onChange);

// Removes all callbacks for a given `context`
eventObj.off(null, null, context);

// Removes all callbacks no matter what
eventObj.off();
</code></pre>
<a name="ampersand-events-trigger" class="anchor" href="#ampersand-events-trigger"><h3><span class="header-link"></span>trigger <code>eventObj.trigger(eventName, [argsToPassOn])</code></h3></a><p>Triggers all the callbacks for the given <code>eventName</code>.</p>
<ul>
<li><code>eventName</code> {String} Name of event, or space-delimited list of events.</li>
<li><code>argsToPassOn</code> { ... } Any additional arguments will simply be used to call the callbacks that are listening for this event.</li>
</ul>
<pre><code class="javascript">eventObj.on(&#39;change&#39;, function (payload) {
    // `payload` will be the `{some: &#39;object&#39;}` instance
    // from below.
});
eventObj.trigger(&#39;change&#39;, {some: &#39;object&#39;});
</code></pre>
<a name="ampersand-events-listento" class="anchor" href="#ampersand-events-listento"><h3><span class="header-link"></span>listenTo <code>eventObj.listenTo(otherEventObj, eventName, callback)</code></h3></a><p>Tell an <code>eventObject</code> to listen to <code>eventName</code> on another object. This is another form of <code>on</code> that makes it easier to create an object that listens to events from other objects and keep track of them. This makes it so we can easily listen to several different events from several different objects but make it simple to remove them all at once. </p>
<p>For example, if we use <code>.listenTo</code> to listen to model changes it cares about in an ampersand-view the view will know what callbacks it needs to unregister if it gets removed.</p>
<ul>
<li><code>otherEventObj</code> {Event object} The other object to listen to.</li>
<li><code>eventName</code> {String} Event to listen to (can also be space delimited list of events).</li>
<li><code>callback</code> {Function} The function to call when event occurs.</li>
</ul>
<p><strong>Note:</strong> the callback will always be called with the <code>eventObj</code> as the <code>this</code> value.</p>
<pre><code class="javascript">view.listenTo(model, &#39;change&#39;, view.render);
// when `view.render` is called `this` will be `view`
</code></pre>
<a name="ampersand-events-listentoonce" class="anchor" href="#ampersand-events-listentoonce"><h3><span class="header-link"></span>listenToOnce <code>eventObj.listenToOnce(otherEventObj, eventName, callback)</code></h3></a><p>Same as <code>listenTo</code> but it unregisters itself after getting called once no matter how many times the events is triggered.</p>
<a name="ampersand-events-listentoandrun" class="anchor" href="#ampersand-events-listentoandrun"><h3><span class="header-link"></span>listenToAndRun <code>eventObj.listenToAndRun(otherEventObj, eventName, callback)</code></h3></a><p>Same as <code>listenTo</code> but also immediately executes the registered callback once right away. This can be useful for things like methods that re-calculate totals, but that also need to be run once to calculate the initial value.</p>
<a name="ampersand-events-stoplistening" class="anchor" href="#ampersand-events-stoplistening"><h3><span class="header-link"></span>stopListening <code>eventObj.stopListening([otherEventObj], [eventName], [callback])</code></h3></a><p>Tells the <code>eventObj</code> to stop listening to events. Most commonly it&#39;s used without arguments to remove all callbacks an object registered before destroying the object. For example <code>ampersand-view</code> calls <code>this.stopListening()</code> as part of <code>.remove()</code>. </p>
<p>However, you can also use <code>stopListening</code> with specific objects, events or callbacks.</p>
<ul>
<li><code>otherEventObj</code> {Event object} The other object being listened to.</li>
<li><code>eventName</code> {String} A specific string or space-delimited list of events to stop listening to.</li>
<li><code>callback</code> {Function} A specific callback to remove.</li>
</ul>
<p>These can be used in any combination as shown below:</p>
<pre><code class="javascript">// Stops listening to everything
eventObj.stopListening();

// Stop listening to a specific object
eventObj.stopListening(object);

// Stop listening to all &#39;change&#39; events from any model
eventObj.stopListening(null, &#39;change&#39;);

// Remove just a specific `callback`
eventObj.stopListening(null, null, callback);
</code></pre>
</div>
        </section>
        <section class="module"><a href="https://github.com/ampersandjs/ampersand-dom-bindings#readme/edit/master/README.md" class="button button-small button-edit">Suggest an edit</a><a name="ampersand-dom-bindings" href="#ampersand-dom-bindings" class="anchor">
            <h1><span class="header-link"></span>ampersand-dom-bindings</h1></a>
          <div class="module-card">
            <h4 class="module-name">ampersand-dom-bindings</h4>
            <p class="module-version">latest v3.8.0</p>
            <p class="module-description">Takes binding declarations and returns key-tree-store of functions that can be used to apply those bindings.</p>
            <p class="module-links"><a href="https://github.com/ampersandjs/ampersand-dom-bindings#readme">github</a><a href="https://www.npmjs.org/package/ampersand-dom-bindings">npm</a></p>
          </div>
          <div><p>Takes binding declarations as described below and returns <a href="https://github.com/HenrikJoreteg/key-tree-store">key-tree-store</a> of functions that can be used to apply those bindings to a DOM tree.</p>
<p><a href="http://ampersandjs.com/docs#ampersand-view">ampersand-view</a> use this for declarative bindings.</p>
<p>The returned functions should be called with these arguments: The root element, the current value of the property, and a name for the binding types where that is relevant.</p>
<a name="ampersand-dom-bindings-install" class="anchor" href="#ampersand-dom-bindings-install"><h2><span class="header-link"></span>install</h2></a><pre><code>npm install ampersand-dom-bindings
</code></pre><a name="ampersand-dom-bindings-binding-types" class="anchor" href="#ampersand-dom-bindings-binding-types"><h2><span class="header-link"></span>Binding types</h2></a><a name="ampersand-dom-bindings-text" class="anchor" href="#ampersand-dom-bindings-text"><h3><span class="header-link"></span>text</h3></a><p>sets/maintains <code>textContent</code> of selected element. treats <code>undefined</code>, <code>null</code>, and <code>NaN</code> as <code>&#39;&#39;</code></p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;text&#39;,
    selector: &#39;.someSelector&#39; // or hook
}
</code></pre>
<a name="ampersand-dom-bindings-class" class="anchor" href="#ampersand-dom-bindings-class"><h3><span class="header-link"></span>class</h3></a><p>sets and maintains single class as string that matches value of property</p>
<ul>
<li>handles removing previous class if there was one</li>
<li>treats <code>undefined</code>, <code>null</code>, and <code>NaN</code> as <code>&#39;&#39;</code> (empty string).</li>
</ul>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;class&#39;,
    selector: // or hook
}
</code></pre>
<a name="ampersand-dom-bindings-attribute" class="anchor" href="#ampersand-dom-bindings-attribute"><h3><span class="header-link"></span>attribute</h3></a><p>sets the whole attribute to match value of property. treats <code>undefined</code>, <code>null</code>, and <code>NaN</code> as <code>&#39;&#39;</code> (empty string). <code>name</code> can also be an array to set multiple attributes to the same value.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;attribute&#39;,
    selector: &#39;#something&#39;, // or hook
    name: &#39;width&#39;
}
</code></pre>
<a name="ampersand-dom-bindings-value" class="anchor" href="#ampersand-dom-bindings-value"><h3><span class="header-link"></span>value</h3></a><p>sets the value of the element to match value of the property. works well for <code>input</code>, <code>select</code>, and <code>textarea</code> elements. treats <code>undefined</code>, <code>null</code>, and <code>NaN</code> as <code>&#39;&#39;</code> (empty string).</p>
<p><strong>note</strong>: The binding will only be applied if the element is not currently in focus. This is done by checking to see if the element is the <code>document.activeElement</code> first. The reason it works this way is because if you&#39;ve set up two-way data bindings you get a circular event: the input changes, which sets the bound model property, which in turn updates the value of the input. This might sound OK but results in the cursor always jumping to the end of the input/textarea. So if you&#39;re editing the middle of a bound text field, the cursor keeps jumping to the end. We avoid this by making sure it&#39;s not already in focus thus avoiding the bad loop.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;value&#39;,
    selector: &#39;#something&#39;, // or hook
}
</code></pre>
<a name="ampersand-dom-bindings-booleanclass" class="anchor" href="#ampersand-dom-bindings-booleanclass"><h3><span class="header-link"></span>booleanClass</h3></a><p>add/removes class based on boolean interpretation of property name. <code>name</code>, <code>yes</code>, or <code>no</code> can also be an array of class names where all the values will be toggled. If you need the opposite effect, (<code>false</code> adds class, <code>true</code> removes class), specify <code>invert: true</code>.</p>
<pre><code class="javascript">&#39;model.active&#39;: {
    type: &#39;booleanClass&#39;,
    selector: &#39;#something&#39;, // or hook
    // to specify name of class to toggle (if different than key name)
    // you could either specify a name
    name: &#39;active&#39;
    // or a yes/no case
    yes: &#39;active&#39;,
    no: &#39;not-active&#39;
    // if you need inverse interpretation
    invert: true
}
</code></pre>
<a name="ampersand-dom-bindings-booleanattribute" class="anchor" href="#ampersand-dom-bindings-booleanattribute"><h3><span class="header-link"></span>booleanAttribute</h3></a><p>toggles whole attribute on the element (think <code>checked</code>) based on boolean interpretation of property name. <code>name</code> can also be an array of attribute names where all the values will be toggled. If you need the opposite effect, (<code>false</code> adds attribute, <code>true</code> removes attribute), specify <code>invert: true</code>.</p>
<pre><code class="javascript">&#39;model.isAwesome&#39;: {
    type: &#39;booleanAttribute&#39;,
    selector: &#39;#something&#39;, // or hook
    // to specify name of attribute to toggle (if different than key name)
    // you could either specify a name
    name: &#39;checked&#39;
    // or a yes/no case
    yes: &#39;data-is-awesome&#39;,
    no: &#39;data-is-not-awesome&#39;
    // if you need inverse interpretation
    invert: true
}
</code></pre>
<a name="ampersand-dom-bindings-toggle" class="anchor" href="#ampersand-dom-bindings-toggle"><h3><span class="header-link"></span>toggle</h3></a><p>toggles visibility (using display: none by default) of entire element based on boolean interpretation of property.</p>
<pre><code class="javascript">// simple show/hide of single element
&#39;model.key&#39;: {
    type: &#39;toggle&#39;,
    selector: &#39;#something&#39; // or hook
}

// Inverse interpretation of value
&#39;model.key&#39;: {
    type: &#39;toggle&#39;,
    invert: true,
    hook: &#39;some-element&#39;
}

// toggle visibility property instead
&#39;model.key&#39;: {
    type: &#39;toggle&#39;,
    selector: &#39;#something&#39;, // or hook
    mode: &#39;visibility&#39;
}

// show/hide where true/false show different things
&#39;model.key&#39;: {
    type: &#39;toggle&#39;,
    yes: &#39;#true_case&#39;,
    no: &#39;#false_case&#39;
}
</code></pre>
<a name="ampersand-dom-bindings-switch" class="anchor" href="#ampersand-dom-bindings-switch"><h3><span class="header-link"></span>switch</h3></a><p>Toggles existence of multiple items based on value of property.</p>
<pre><code class="javascript">&#39;model.activetab&#39;: {
    type: &#39;switch&#39;,
    cases: {
        &#39;edit&#39;: &#39;#edit_tab&#39;,
        &#39;new&#39;: &#39;#new_tab&#39;,
        &#39;details&#39;: &#39;#details_tab&#39;
    }
}
</code></pre>
<a name="ampersand-dom-bindings-switchclass" class="anchor" href="#ampersand-dom-bindings-switchclass"><h3><span class="header-link"></span>switchClass</h3></a><p>Toggles existence of a class on multiple elements based on value of property.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;switchClass&#39;,
    name: &#39;is-active&#39;,
    cases: {
        &#39;edit&#39;: &#39;#edit_tab&#39;,
        &#39;new&#39;: &#39;#new_tab&#39;,
        &#39;details&#39;: &#39;#details_tab&#39;
    }
}
</code></pre>
<a name="ampersand-dom-bindings-switchattribute" class="anchor" href="#ampersand-dom-bindings-switchattribute"><h3><span class="header-link"></span>switchAttribute</h3></a><p>Sets attribute(s) on matching elements based on the value of a property matching the case.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;switchAttribute&#39;,
    selector: &#39;a&#39;, // or hook
    name: &#39;href&#39;,  // name defaults to the property name (e.g. &#39;key&#39; from &#39;model.key&#39; in this example)
    cases: {
        value1: &#39;/foo&#39;,
        value2: &#39;/bar&#39;
    }
}
</code></pre>
<p>You can also specify multiple attributes by using an object as the case value. The object keys are used instead of the <code>name</code> option.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;switchAttribute&#39;,
    selector: &#39;a&#39;, // or hook
    cases: {
        value1: { href: &#39;/foo&#39;, name: &#39;foo&#39; },
        value2: { href: &#39;/bar&#39;, name: &#39;bar&#39; }
    }
}
</code></pre>
<a name="ampersand-dom-bindings-innerhtml" class="anchor" href="#ampersand-dom-bindings-innerhtml"><h3><span class="header-link"></span>innerHTML</h3></a><p>renders innerHTML, can be a string or DOM, based on property value of model</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: &#39;innerHTML&#39;,
    selector: &#39;#something&#39; // or hook
}
</code></pre>
<a name="ampersand-dom-bindings-custom-functions" class="anchor" href="#ampersand-dom-bindings-custom-functions"><h3><span class="header-link"></span>custom functions</h3></a><p><code>type</code> can also be a function. It will be run for each matching <code>el</code> with the
<code>value</code> and <code>previousValue</code> of the property. The function is bound to the view
declaring the bindings, so <code>this</code> refers to the view.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    type: function (el, value, previousValue) {
        // Do something custom to el
        // using value and/or previousValue
    },
    selector: &#39;#something&#39;, // or hook
}
</code></pre>
<a name="ampersand-dom-bindings-handling-multiple-bindings-for-a-given-key" class="anchor" href="#ampersand-dom-bindings-handling-multiple-bindings-for-a-given-key"><h2><span class="header-link"></span>Handling multiple bindings for a given key</h2></a><p>If given an array, then treat each contained item as separate binding</p>
<pre><code class="javascript">&#39;model.key&#39;: [
    {
        type: &#39;booleanClass&#39;,
        selector: &#39;#something&#39;, // or hook
        name: &#39;active&#39; // (optional) name of class to toggle if different than key name
    },
    {
        type: &#39;attribute&#39;,
        selector: &#39;#something&#39;, // or hook
        name: &#39;width&#39;
    }
]
</code></pre>
<p>The <code>attribute</code>, <code>booleanAttribute</code> and <code>booleanClass</code> types also accept an array for the <code>name</code> property (and <code>yes</code>/<code>no</code> for <code>booleanClass</code>). All the values in the array will be set the same as if each were bound separately.</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    // Also works with booleanAttribute and booleanClass
    type: &#39;attribute&#39;,
    selector: &#39;#avatar&#39;,
    // Both height and width will be bound to model.key
    name: [&#39;height&#39;, &#39;width&#39;]
}
</code></pre>
<a name="ampersand-dom-bindings-binding-using-attribute" class="anchor" href="#ampersand-dom-bindings-binding-using-attribute"><h2><span class="header-link"></span>binding using <code>data-hook</code> attribute</h2></a><p>We&#39;ve started using this convention a lot, rather than using classes and IDs in JS to select elements within a view, we use the <code>data-hook</code> attribute. This lets designers edit templates without fear of breaking something by changing a class. It works wonderfully, but the only thing that sucks about that is the syntax of attribute selectors: <code>[data-hook=some-hook]</code> is a bit annoying to type a million types, and also in JS-land when coding and we see <code>[</code> we always assume arrays.</p>
<p>So for each of these bindings you can either use <code>selector</code> or <code>hook</code>, so these two would be equivalent:</p>
<pre><code class="javascript">&#39;model.key&#39;: {
    selector: &#39;[data-hook=my-element]&#39;
}

&#39;model.key&#39;: {
    hook: &#39;my-element&#39;
}
</code></pre>
<a name="ampersand-dom-bindings-handling-simplest-cases-text" class="anchor" href="#ampersand-dom-bindings-handling-simplest-cases-text"><h2><span class="header-link"></span>handling simplest cases: text</h2></a><pre><code class="javascript">&#39;model.key&#39;: &#39;#something&#39; // creates `text` binding for that selector and property

// `type` defaults to `text` so we can also do
&#39;model.key&#39;: {
    hook: &#39;hook-name&#39;
}
</code></pre>
<a name="ampersand-dom-bindings-real-life-example" class="anchor" href="#ampersand-dom-bindings-real-life-example"><h2><span class="header-link"></span>real life example</h2></a><pre><code class="javascript">var View = require(&#39;ampersand-view&#39;);
var templates = require(&#39;../templates&#39;);


module.exports = View.extend({
    template: templates.includes.app,
    bindings: {
        &#39;model.client_name&#39;: {
            hook: &#39;name&#39;
        },
        &#39;model.logo_uri&#39;: {
            type: &#39;attribute&#39;,
            name: &#39;src&#39;,
            hook: &#39;icon&#39;
        }
    }
});
</code></pre>
<a name="ampersand-dom-bindings-other-benefits" class="anchor" href="#ampersand-dom-bindings-other-benefits"><h2><span class="header-link"></span>other benefits</h2></a><p>Previously after having given views the ability to have their own properties (since view inherits from state) it was awkward to bind those to the DOM. Also, for binding things that were not just <code>this.model</code> the syntax had to change.</p>
<p>Now this is fairly simple/obvious:</p>
<pre><code class="javascript">module.exports = View.extend({
    template: templates.includes.app,
    props: {
        activetab: &#39;string&#39;,
        person: &#39;state&#39;,
        meeting: &#39;state&#39;
    },
    bindings: {
        // for the property that&#39;s directly on the view
        &#39;activetab&#39;: {
            type: &#39;switch&#39;,
            case: {
                &#39;edit&#39;: &#39;#edit_tab&#39;,
                &#39;new&#39;: &#39;#new_tab&#39;,
                &#39;details&#39;: &#39;#details_tab&#39;
            }
        },
        // this one is for one model
        &#39;person.full_name&#39;: &#39;[data-hook=name]&#39;,
        // this one is for another model
        &#39;meeting.subject&#39;: &#39;[data-hook=subject]&#39;
    }
});
</code></pre>
</div>
        </section>
      </div>
    </div>
    <script src="/public/js/setup.js"></script>
    <footer class="footer-main">
      <nav class="nav-footer cf">
        <div><a href="/learn" class="nav-item">Learn</a><a href="/docs" class="nav-item">Docs</a><a href="http://tools.ampersandjs.com" class="nav-item">Modules</a></div>
        <div><a href="http://amp.ampersandjs.com/" class="nav-item external">Amp</a><a href="https://gitter.im/AmpersandJS/AmpersandJS" class="nav-item external">Chatroom</a><a href="/contribute" class="nav-item">Contribute</a></div>
        <div><a href="/security" class="nav-item">Security</a><a href="https://github.com/ampersandjs" class="nav-item">Github</a><a href="https://twitter.com/ampersandjs" class="nav-item">Twitter</a></div>
      </nav>
      <p>Sponsored by <a href="https://andyet.com">&amp;yet </a><br>with the help of our <a href="/contribute">contributors</a></p><a href="/" class="logo logo-ampersand-gray">&amp;</a>
    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44685415-1', 'humanjavascript.com');
      ga('send', 'pageview');
      
    </script>
    <script src="/public/js/highlight.pack.js"></script>
    <script>
      hljs.configure({classPrefix: ''});
      hljs.initHighlightingOnLoad();
      
    </script>
  </body>
</html>
